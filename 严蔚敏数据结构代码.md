# 线性表
## 顺序表-代码实现算法2.1-2.7
```

#include<bits/stdc++.h>
using namespace std;
#define MaxSize 100
#define LIST_INIT_SIZE 100
#define LISTINCREMENT 10
#define ElemType int 
#define Status int

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
}SqList,List;

Status InitList(SqList &L){
    //构造一个空的线性表一
    L.elem = (ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(_OVERFLOW);
    L.length = 0;
    L.listsize = LIST_INIT_SIZE;
    return 1;
}
Status DestoryList(SqList &L){
    //销毁线性表
    delete (L.elem);
    L.elem = NULL;
    L.length = 0;
    L.listsize = 0;
    return 1;
}
Status ClearList(SqList &L){
    //将L重置为空表
    L.length = 0;
    return 1;
}
bool ListEmpty(SqList L){
    //若L为空表，则返回TRUE，否则返回FALSE;
    if(0 == L.length)
        return true;
    return false;
}
Status ListLength(SqList L){
    //返回L中数据元素个数
    return L.length;
}
Status GetElem(SqList L,int i,ElemType &e){
    //用e返回L中第i个元素的值
    if(i<1||i>L.length)
        exit(0);
    e = *(L.elem + i - 1);
    return 1;
}
Status LocateElem(SqList L,ElemType &e,Status(* compare)(ElemType,ElemType)){
    //返回L中第一个e满足compare（）的数据元素的位序，若不存在，则返回0；
    int i = 1;
    ElemType *p = L.elem;
    while(i <= L.length && !(*compare)(*p++ , e))
        ++i;
    if(i<=L.length)
        return i;
    else
        return 0;
}
Status PriorElem(SqList L,ElemType cur_e,ElemType &pre_e){
    //cur_e的前驱节点
    int i = 2;
    ElemType *p = L.elem + 1;
    while(i <= L.length && *p != cur_e){
        p++;
        i++;
    }
    if(i > L.length)
        return -1;
    pre_e = *(--p);
    return 1;
}
Status NextElem(SqList L,ElemType cur_e,ElemType &next_e){
    //cur_e的后继节点
    int i = 1;
    ElemType *p = L.elem;
    while(i < L.length && *p != cur_e){
        i++;
        p++;
    }
    if(i == L.length)
        return -1;
    next_e = *(++p);
    return 1;
}
Status ListInsert(SqList &L,int i,ElemType e){
    //在L中第i个位置之前插入新的数据元素e，L长度+1
    if(i<1||i>L.length+1)
        return 0;
    if(L.length>=L.listsize){
        ElemType *newbase = (ElemType *)realloc(L.elem, 
            (L.listsize + LISTINCREMENT) * sizeof(ElemType));
        if(NULL == newbase)
            exit(_OVERFLOW);
        L.elem = newbase;
        L.listsize += LISTINCREMENT;
    }
    for (int j = L.length - 1; j >= i - 1;j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    L.length++;
    return 1;
}
Status ListDelet(SqList &L,int i,ElemType &e){
    //删除L的第i个位置的数据元素，并用e返回其值，L长度-1
    if(i<1||i>L.length)
        return 0;
    e = L.elem[i - 1];
    for (int j = i - 1; j < L.length - 1;j++)
        L.elem[j] = L.elem[j + 1];
    L.length--;
    return 1;
}
Status ListTraverse(SqList L,void(*visit)(ElemType*)){
    //依次对L的每个元素调用visit()函数，一旦失败，则操作失败
    ElemType *p = L.elem;
    for (int i = 1; i <= L.length;i++){
        visit(p++);
    }
    cout << endl;
    return 1;
}

//算法2.1
ElemType e;
Status equal(ElemType a,ElemType b){
    if( a == b )
        return 1;
    else
        return 0;
}
void unionlist(List &La, List Lb){
    int La_len = ListLength(La);
    int Lb_len = ListLength(Lb);
    for (int i = 1; i <= Lb_len;i++){
        GetElem(Lb, i, e);
        if(!LocateElem(La,e,equal))//函数指针
            ListInsert(La, ++La_len, e);
    }
}

//算法2.2
void MergeList(List La,List Lb,List &Lc){
    InitList(Lc);
    int i, j, k;
    int a[100], b[100];
    i = j = 1;
    k = 0;
    int La_len = ListLength(La);
    int Lb_len = ListLength(Lb);
    while((i<=La_len)&&(j<=Lb_len)){
        GetElem(La, i, a[i]);
        GetElem(Lb, i, b[i]);
        if(a[i]<b[j]){
            ListInsert(Lc, ++k, a[i]);
            ++i;
        }
        else{
            ListInsert(Lc, ++k, b[j]);
            ++j;
        }
    }
    while(i<=La_len){
        GetElem(La, i++, a[i]);
        ListInsert(Lc, ++k, a[i]);
    }
    while(j<=Lb_len){
        GetElem(Lb, j++, b[j]);
        ListInsert(Lc, ++k, b[j]);
    }
}

//算法2.3
Status InitList_Sq(SqList &L){
    L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if(!L.elem)
        exit(_OVERFLOW);
    L.length = 0;
    L.listsize = LIST_INIT_SIZE;
    return 1;
}

//算法2.4
Status ListInsert_Sq(SqList &L,int i,ElemType e){
    //在L中第i个位置之前插入新的数据元素e，L长度+1
    if(i<1||i>L.length+1)
        return 0;
    if(L.length>=L.listsize){
        ElemType *newbase = (ElemType *)realloc(L.elem, 
            (L.listsize + LISTINCREMENT) * sizeof(ElemType));
        if(NULL == newbase)
            exit(_OVERFLOW);
        L.elem = newbase;
        L.listsize += LISTINCREMENT;
    }
    for (int j = L.length - 1; j >= i - 1;j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    L.length++;
    return 1;
}

//算法2.5
Status ListDelete_Sq(SqList &L,int i,ElemType &e){
    //删除L的第i个位置的数据元素，并用e返回其值，L长度-1
    if(i<1||i>L.length)
        return 0;
    ElemType *p = &(L.elem[i - 1]),*q;
    e = *p;
    q = L.elem + L.length - 1;
    for (++p; p <= q;++p)
        *(p - 1) = *p;
    --L.length;
    return 1;
}

//算法2.6
Status LocateElem_Sq(SqList L,ElemType &e,Status(* compare)(ElemType,ElemType)){
    //返回L中第一个e满足compare（）的数据元素的位序，若不存在，则返回0；
    int i = 1;
    ElemType *p = L.elem;
    while(i <= L.length && !(*compare)(*p++ , e))
        ++i;
    if(i<=L.length)
        return i;
    else
        return 0;
}

//算法2.7
void MergeList_Sq(SqList La,SqList Lb,SqList &Lc){
    ElemType *pa, *pb, *pc, *pa_last, *pb_last;
    pa = La.elem;
    pb = Lb.elem;
    Lc.listsize = Lc.length = La.length + Lb.length;
    pc = Lc.elem = (ElemType *)malloc(Lc.listsize * sizeof(ElemType));
    if(!Lc.elem)
        exit(_OVERFLOW);
    pa_last = La.elem + La.length - 1;
    pb_last = Lb.elem + Lb.length - 1;
    while(pa <= pa_last && pb <= pb_last){
        if (*pa <= *pb)
            *pc++ = *pa++;
        else
            *pc++ = *pb++;
    }
    while (pa <= pa_last)
        *pc++ = *pa++;
    while (pb <= pb_last)
        *pc++ = *pb++;
}

```

# 单链表-代码实现算法2.8-2.12
```
#include<bits/stdc++.h>
using namespace std;
#define ElemType int 
#define Status int

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

//算法2.8
//获得第i个元素把他赋给e
Status GetElem_L(LinkList L,int i,ElemType &e){
    LinkList p = L->next;
    int j = 1;
    while(p&&j<i){
        p = p->next;
        j++;
    }
    if(!p||j<i)
        return 0;
    e = p->data;
    return 1;
}

//算法2.9
//在i位置之前插入元素e
Status ListInsert_L(LinkList &L,int i,ElemType e){
    LinkList p = L;
	int j = 0;
	while (p && j < i - 1) 
	{
		p = p->next;
		j++;
	}
	if (!p || j > i - 1)
        return 0;
    LinkList s = (LinkList)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s;
	return 1;
}

//算法2.10
//删除第i个元素，由e返回其值
Status ListDelete_L(LinkList &L,int i,ElemType &e){
    LinkList p = L;
	int j = 0;
	while (p->next && j < i - 1)
	{
		p = p->next;
		j++;
	}
	if (!(p->next) || j > i - 1)
        return 0;
    LinkList q = p->next;
	p->next = q->next;
	e = q->data;
	free(q);
	return 1;
}

//算法2.11
//逆位序输入n个元素的值，建立带表头结点的单链线性表L
void CreateList_L(LinkList &L,int n){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    ElemType e;
    for (int i = n; i > 0;i--){
        LinkList p = (LinkList)malloc(sizeof(LNode));
        scanf("%d", &e);
        p->data = e;
        p->next = L->next;
        L->next = p;
    }
}

//算法2.12
//单链表La,Lb的元素归并到Lc,Lc元素按值非递减排列
void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc){
    LinkList pa = La->next;
    LinkList pb = Lb->next;
    LinkList pc;
    La = pc = La;
	while (pa && pb)
	{
		if (pa->data <= pb->data)
		{
			pc->next = pa;
			pc = pa;
            pa = pa->next;
        }
		else
		{
			pc->next = pb;
			pc = pb;
			pb = pb->next;
		}
	}
	pc->next = pa ? pa : pb;
	free(Lb);
	La = NULL;
    Lb = NULL;
}

```

## 静态链表-代码实现算法2.13-2.17
```
#include<bits/stdc++.h>
using namespace std;
#define Status int
#define ElemType int
#define MAXSIZE 1000

typedef struct{
    ElemType data;
    int cur;
} compoent, SLinkList[MAXSIZE];

//算法2.13
int LocateElem_SL(SLinkList S,ElemType e){
    //在静态链表L中查找第1个值为e的元素
    int i = S[0].cur;//i指示表中第一个结点
    while(i&&S[i].data!=e){ //在表中顺链查找
        i = S[i].cur;
    }
    return i;
}

//算法2.14
void InitSpace_SL(SLinkList &space){
    //将一维数组space中各分量链成一个备用链表，space[0].cur为头指针
    for (int i = 0; i < MAXSIZE - 1;i++){
        space[i].cur = i + 1;
    }
    space[MAXSIZE - 1].cur = 0;
}

//算法2.15
int Malloc_SL(SLinkList &space){
    //
    int i = space[0].cur;
    if(space[0].cur)
        space[0].cur = space[i].cur;
    return i;
}

//算法2.16
void Free_SL(SLinkList &space,int k){
    //
    space[k].cur = space[0].cur;
    space[0].cur = k;
}

//算法2.17
void difference(SLinkList &space,int &S){
    //
    InitSpace_SL(space);
    S = Malloc_SL(space);
    int r = S;
    int m, n, data, i;
    scanf("%d %d", &m, &n);
    for (int j = 1; j <= m;j++){
        i = Malloc_SL(space);
        scanf("%d", &data);
        space[i].data = data;
        space[r].cur = i;
        r = i;
    }
    space[r].cur = 0;
    for (int j = 1; j <= n;j++){
        int b;
        scanf("%d", &b);
        int p = S;
        int k = space[S].cur;
        while(k!=space[r].cur&&space[k].data!=b){
            p = k;
            k = space[k].cur;
        }
        if(k==space[r].cur){
            i = Malloc_SL(space);
            space[i].data = b;
            space[i].cur = space[r].cur;
            space[r].cur = i;
        }else{
            space[p].cur = space[k].cur;
            Free_SL(space, k);
            if(r==k)
                r = p;
        }
    }
}

```


## 双向链表-代码实现算法2.18-2.19
```
#include <bits/stdc++.h>
using namespace std;
#define ElemType int
#define Status int

typedef struct DuLNode{
    ElemType data;
    struct DuLNode *prior;
    struct DuLNode *next;
} DuLNode, *DuLinkList;

void Init_DuL(DuLinkList &L){
    L = (DuLinkList)malloc(sizeof(DuLNode));
    L->data = NULL;
    L->next = L;
    L->prior = L;
}

//链表长度
Status Length_DuL(DuLinkList &L){
    DuLinkList p;
    p = L->next;
    int i = 0;
    while (p->data != NULL)
    {
        p = p->next;
        i++;
    }
    return i;
}

DuLinkList GetElemP_DuL(DuLinkList &L, int i){
    DuLinkList p = L->next;
    int j = 1;
    while (p && j < i){
        //p不为空或者计数器j还没有等于i时，循环继续
        p = p->next;
        ++j;
    }
    if (!p || j > i || i > (Length_DuL(L) + 1)){
        //第i个元素不存在或i大于表长加1时，p指向空
        p = NULL;
    }
    if (i == Length_DuL(L) + 1){
        //i等于表长加1时，p指向头结点
        p = L;
    }
    return p;
}

//算法2.18
//带头结点的双链循环线性表L中第i个位置之前插入元素e
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e)
{
    //在带条结点的双链循环线性表L中第i个位置之前插入元素e
    //i的合法值为1<=i<=表长+1
    DuLinkList p, s;
    if (!(p = GetElemP_DuL(L, i))) //在L中确定插入位置指针p
        return 0;
    if (!(s = (DuLinkList)malloc(sizeof(DuLNode))))
    {
        return 0;
    }
    s->data = e;
    s->prior = p->prior;
    p->prior->next = s;
    s->next = p;
    p->prior = s;
    return 1;
}
//算法2.19
//删除带头结点的双链循环线性表L的第i个元素
Status ListDelete_DuL(DuLinkList &L, int i, ElemType &e)
{
    DuLinkList p;
    if (!(p = GetElemP_DuL(L, i)))
    {                 //在L中确定第i个元素的位置指针
        return 0; //p=NULL，即第i个元素不存在
    }
    e = p->data;
    p->prior->next = p->next;
    p->next->prior = p->prior;
    free(p);
    return 1;
}

//释放销毁
void Destory_DuL(DuLinkList &L)
{
    DuLinkList p, q;
    p = L->next;
    while (p->data != NULL)
    {
        q = p->next;
        p->prior->next = p->next;
        p->next->prior = p->prior;
        free(p);
        p = q;
    }
    free(L);
}
```
## 带头结点的线性表-代码实现算法2.20-2.21
```
#include <bits/stdc++.h>
using namespace std;
#define ElemType int
#define Status int

typedef struct LNode{
    ElemType data;
    struct LNode *next;
} * Link, *Position;

typedef struct{
    Link head, tail;
    int len;
} LinkList;

Status MakeNode(Link &p, ElemType e){
    //分配一个p指向的值为e的节点，并返回OK；如果分配失败，则error
    p = new LNode;
    p->data = e;
    if(p)
        return 1;
    else
        return 0;
}

void FreeNode(Link &p){
    //释放p指向的节点
    delete p;
    p = NULL;
}

Status InitList(LinkList &L){
    //初始化一个已经声明链表L
    L.head = new LNode;
    L.head->next = NULL;
    L.tail = L.head;
    L.len = 0;
    if(L.head){
        cout << "初始化成功"<<endl;
        return 1;
    }else
        return 0;
}

Status DestroyList(LinkList &L){
    //销毁一个链表L
    ClearList(L);
    delete L.head;
    L.head = NULL;
    L.tail = NULL;
    if(!L.head)
        return 1;
    else
        return 0;
}

Status ClearList(LinkList &L){
    //将当前链表L清空，变成一个初始状态的链表
    Link p = L.head->next;
    while(p){
        L.head->next = p->next;
        delete p;
        p = NULL;
        L.len--;
        p = L.head->next;
    }
    if(L.head->next==NULL){
        return 1;
    }else
        return 0;
}

Status InsFirst(Link h, Link s){
    //在头节点位置插入一个新的节点,h指向头，s指向新的节点
    s->next = h->next;
    h->next = s;
    return 1;
}
Status DelFirst(Link h, Link &q){
    //将头节点删除
    q = h->next;
    if(q){
        h->next = q->next;
        return 1;
    }else
        return 0;
}
Status Append(LinkList &L, Link s){
    //向链表内插入数据，s以后的一个或若干个节点插入链表的尾部
    //并修改链表的tail指针
    L.tail->next = s;
    while (L.tail->next!=NULL){
        L.len++;
        L.tail = L.tail->next;
    }
    return 1;
}
Status Remove(LinkList &L, Link &q){
    //删除链表尾节点元素，由q返回
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
    q = L.head;
    while(q->next!=L.tail){
        q = q->next;
    }
    L.tail = q;
    q = q->next;
    L.tail->next = NULL;
    L.len--;
	delete q;
    q = NULL;
    return 1;
}
Status InsBefore(LinkList &L, Link &p, Link s){
    //将元素插入由p指定的位置的前一个位置,并修改p指向新的节点
    Link q = L.head;
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
	while(q->next!=p){
        q = q->next;
    }
    q->next = s;
    s->next = p;
    p = s;
    L.len++;
	return 1;
}
Status InsAfter(LinkList &L, Link &p, Link s){
    //将元素插入由p指定位置的下一个位置，并修改p指向新节点
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
    s->next = p->next;
    p->next = s;
    if(p==L.tail)
        L.tail = L.tail->next;
    p = s;
    L.len++;
	return 1;
}
Status SetCurElm(Link &p, ElemType e){
    //修改当前指针p指向的元素的数据域的值为e
    p->data = e;
    return 1;
}
ElemType GetCurElem(Link p){
    //获取当前指针p指向的元素的数据域的值，以e返回
    return p->data;
}
Status ListEmpty(LinkList L){
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
    if(L.head->next==NULL)
        return 1;
    else
        return 0;
}
int ListLength(LinkList L){
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	return L.len;
}
Position GetHead(LinkList L)
{
    //返回链表当中头节点的位置
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	return L.head;
}
Position GetLast(LinkList L)
{
    //返回链表当中最后一个节点的位置
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
	return L.tail;

}
Position PriorPos(LinkList L, Link p)
{
    //由当前p指向的位置，查找p的邻接前一个节点的位置
    Link q = L.head;
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	if(p==L.head)
		return NULL;
	while(q->next!=p){
        q = q->next;
    }
	return q;
}
Position NextPos(LinkList L, Link p)
{
    //由当前p指向的位置，查找p的下一个邻接元素的位置
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
	if(p==L.tail)
		return NULL;
    return p->next;
}
Status LocatePos(LinkList L,int i,Link &p)
{
    //获取当前链表内第i个元素的位置，如果i不存在，则ERROR
    int j = 0;
    Link pt = L.head;
    while(pt&&j<i)
	{
        pt = pt->next;
        j++;
	}
	if(!pt||j>i)
		return 0;
	else{
		p=pt;
		return 1;
    }
}

Status compare(ElemType x,ElemType y)
{
	if(x==y)
		return 1;
	else
		return 0;
}
Position LocateElem(LinkList L,ElemType e,Status (*compare)(ElemType,ElemType)){
    Link q = L.head->next;
    while(q->next!=NULL)
	{
		if(compare(q->data,e))
			return q;
        q = q->next;
    }
	return NULL;
}

Status visit(ElemType x)
{
    cout << x << " ";
    return 1;
}
Status ListTraverse(LinkList L,Status(*visit)(ElemType))
{
    Link q = L.head->next;
    while(q)
	{
		if(visit(q->data))
            q = q->next;
        else
			return 0;
	}
    return 1;
}


//算法2.20
Status ListInsert_L(LinkList &L,int i,ElemType e){
    Link h,s;
    if(!LocatePos(L,i-1,h))
        return 0;
    if(!MakeNode(s,e))
        return 0;
    InsFirst(h, s);
    return 1;
}

//算法2.21
Status MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc,int (*compare)(ElemType,ElemType)){
    if(!InitList(Lc))
        return 0;
    Link ha, hb, pa, pb, q;
    ha = GetHead(La);
    hb = GetHead(Lb);
    pa = NextPos(La, ha);
    pb = NextPos(Lb, hb);
    while(pa&&pb){
        ElemType a, b;
        a = GetCurElem(pa);
        b = GetCurElem(pb);
        if((*compare)(a,b)<=0){
            DelFirst(ha, q);
            Append(Lc, q);
            pa = NextPos(La, ha);
        }else{
            DelFirst(hb, q);
            Append(Lc, q);
            pa = NextPos(Lb, hb);
        }
    }
    if(pa)
        Append(Lc, pa);
    else
        Append(Lc, pb);
    FreeNode(ha);
    FreeNode(hb);
    return 1;
}

```
## 一元多项式的表示及相加、相减、相乘-代码实现算法2.22-2.23
```
#include <bits/stdc++.h>
using namespace std;
#define Status int

typedef struct{
    float coef;
    int expn;
} term,ElemType;

typedef struct LNode{
    ElemType data;
    struct LNode *next;
} * Link, *Position;

typedef struct{
    Link head, tail;
    int len;
} LinkList;

typedef LinkList polynomail;
Status MakeNode(Link &p, ElemType e){
    //分配一个p指向的值为e的节点，并返回OK；如果分配失败，则error
    p = new LNode;
    p->data = e;
    if(p)
        return 1;
    else
        return 0;
}
void FreeNode(Link &p){
    //释放p指向的节点
    delete p;
    p = NULL;
}
Status InitList(LinkList &L){
    //初始化一个已经声明链表L
    L.head = new LNode;
    L.head->next = NULL;
    L.tail = L.head;
    L.len = 0;
    if(L.head){
        cout << "初始化成功"<<endl;
        return 1;
    }else
        return 0;
}
Status ClearList(LinkList &L){
    //将当前链表L清空，变成一个初始状态的链表
    Link p = L.head->next;
    while(p){
        L.head->next = p->next;
        delete p;
        p = NULL;
        L.len--;
        p = L.head->next;
    }
    if(L.head->next==NULL){
        return 1;
    }else
        return 0;
}
Status DestroyList(LinkList &L){
    //销毁一个链表L
    ClearList(L);
    delete L.head;
    L.head = NULL;
    L.tail = NULL;
    if(!L.head)
        return 1;
    else
        return 0;
}

Status InsFirst(LinkList &L,Link h, Link s){
    //在头节点位置插入一个新的节点,h指向头，s指向新的节点
    s->next = h->next;
    h->next = s;
    if(h==L.tail)
        L.tail = h->next;
    L.len++;
    return 1;
}
Status DelFirst(LinkList &L,Link h, Link &q){
    //将头节点删除
    q = h->next;
    if(q){
        h->next = q->next;
        if(!h->next)
            L.tail = h;
        L.len--;
        return 1;
    }else
        return 0;
}
Status Append(LinkList &L, Link s){
    //向链表内插入数据，s以后的一个或若干个节点插入链表的尾部
    //并修改链表的tail指针
    int i = 1;
    L.tail->next = s;
    while(s->next){
        s = s->next;
        i++;
    }
    L.tail = s;
    L.len += i;
    return 1;
}
Status Remove(LinkList &L, Link &q){
    //删除链表尾节点元素，由q返回
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
    q = L.head;
    while(q->next!=L.tail){
        q = q->next;
    }
    L.tail = q;
    q = q->next;
    L.tail->next = NULL;
    L.len--;
	delete q;
    q = NULL;
    return 1;
}
Status SetCurElem(Link &p, ElemType e){
    //修改当前指针p指向的元素的数据域的值为e
    p->data = e;
    return 1;
}
ElemType GetCurElem(Link p){
    //获取当前指针p指向的元素的数据域的值，以e返回
    return p->data;
}
Status ListEmpty(LinkList L){
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
    if(L.head->next==NULL)
        return 1;
    else
        return 0;
}
int ListLength(LinkList L){
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	return L.len;
}
Position GetHead(LinkList L)
{
    //返回链表当中头节点的位置
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	return L.head;
}
Position PriorPos(LinkList L, Link p)
{
    //由当前p指向的位置，查找p的邻接前一个节点的位置
    Link q = L.head;
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
	}
	if(p==L.head)
		return NULL;
	while(q->next!=p){
        q = q->next;
    }
	return q;
}
Position NextPos(LinkList L, Link p)
{
    //由当前p指向的位置，查找p的下一个邻接元素的位置
    if(!L.head){
        cout << "线性链表不存在" << endl;
        return 0;
    }
	if(p==L.tail)
		return NULL;
    return p->next;
}
Status LocateElem(LinkList L,ElemType e,Position &q,Status (*compare)(ElemType,ElemType)){
    Link p = L.head, pp = p;
    p = p->next;
    while(p && (compare(p->data,e)<0)){
        pp = p;
        p = p->next;
    }
    if(!p||compare(p->data,e)>0){
        q = pp;
        return 0;
    }
    else{
        q = p;
        return 1;
    }
}
void visit(ElemType e){
    if (e.coef > 0 && e.coef != 1 && e.expn != 0)
    {
        if (e.expn > 0)
            cout << e.coef << "x^" << e.expn ;
        else
            cout << e.coef << "x^(" << e.expn << ")";
    }
    else if (e.coef < 0 && e.expn != 0)
    {
        if (e.expn > 0)
            cout << "(" << e.coef << ")x^" << e.expn ;
        else
            cout << "(" << e.coef << ")x^(" << e.expn << ")";
    }
    else if (e.coef == 1 && e.expn != 0)
    {
        if (e.expn > 0)
            cout << "x^" << e.expn ;
        else
            cout << "x^(" << e.expn << ")";
    }
    else if (e.expn == 0 && e.coef != 0)
        cout << e.coef;
    else 
        cout << "";
}
Status ListTraverse(LinkList L,void(*visit)(ElemType))
{
    Link p = L.head->next;
    for (int i = 1; i <= L.len;i++)
    {
        visit(p->data);
        if(i!=L.len)
        	cout<<"+";
        p = p->next;
    }
    cout << "\b";
    if(L.len == 0)
        cout << "0";
    return 1;
}
// typedef struct{
//     float coef;
//     int expn;
// } term,ElemType;

// typedef struct LNode{
//     ElemType data;
//     struct LNode *next;
// } * Link, *Position;

// typedef struct{
//     Link head, tail;
//     int len;
// } LinkList;
//---------------基本操作的函数原型-----------------------
//算法2.22
int cmp(term a,term b); 
void CreatPolyn(polynomail &P,int m){
    InitList(P);
    Link h = GetHead(P);
    ElemType e;
    Link q, s;
    e.coef = 0.0;
    e.expn = -1;
    SetCurElem(h, e);
    for (int i = 1; i <= m;i++){
        cout << "第"<<i<<"项"<<"的系数:";
        cin >> e.coef;
        cout << "第" << i << "项" << "的指数:";
        cin >> e.expn;
        if(!LocateElem(P,e,q,cmp) ){
            if(e.coef!=0)
                if(MakeNode(s,e))
                    InsFirst(P, q, s);
        }else{
            q->data.coef = q->data.coef + e.coef;
            if(q->data.coef==0)
                Remove(P, q);
        }
    }
}
void DestoryPolyn(polynomail &P){
    DestroyList(P);
}
void PrintPolyn(polynomail P){
    ListTraverse(P, visit);
}
int PolynLength(polynomail P){
    return ListLength(P);
}
//算法2.23
void AddPolyn(polynomail &Pa,polynomail &Pb){
    Link ha, hb, qa=NULL, qb=NULL;
    ElemType a, b;
    ha = GetHead(Pa); hb = GetHead(Pb);
    if (Pa.len != 0 && Pb.len != 0)
    {
        qa = NextPos(Pa, ha);
        qb = NextPos(Pb, hb);
        while (qa && qb)
        {
            a = GetCurElem(qa);
            b = GetCurElem(qb);
            float sum;
            switch (cmp(a, b))
            {
            case -1:
                ha = qa;
                qa = NextPos(Pa, ha);
                break;
            case 0:
                sum = a.coef + b.coef;
                if (sum != 0){
                    qa->data.coef = sum;
                    ha = qa;
                }
                else{
                    DelFirst(Pa ,ha, qa);
                    FreeNode(qa);
                }
                DelFirst(Pb ,hb, qb);
                qb = NextPos(Pb, hb);
                qa = NextPos(Pa, ha);
                break;
            case 1:
                DelFirst(Pb ,hb, qb);
                InsFirst(Pa ,ha, qb);
                qb = NextPos(Pb, hb);
                qa = NextPos(Pa, ha);
                break;
            }
        }
        if (!ListEmpty(Pb))
            Append(Pa, qb);
        FreeNode(hb);
    }
    if (Pa.len == 0){
        Pa = Pb;
    }
}
void SubtractPolyn(polynomail &Pa,polynomail &Pb){
    Link p;
    p = Pb.head;
    while (p->next)
    {
        p = p->next;
        p->data.coef *= -1;
    }
    AddPolyn(Pa, Pb);
}
void OrderInsert(LinkList &L,ElemType e,int (compare)(ElemType,ElemType)){
    Link q, s;
    if(LocateElem(L,e,q,compare)){
        q->data.coef += e.coef;
        if (!q->data.coef){ //系数为0，删除多项式中当前节点
            s = PriorPos(L, q);
            if(!s)//q无前驱
                s = L.head;
            DelFirst(L, s, q);
            FreeNode(q);
        }
    }else{//生成并插入
        MakeNode(s, e);
        InsFirst(L, q, s);
    }
}
void MultiplyPolyn(polynomail &Pa,polynomail &Pb){
    Link qa = GetHead(Pa);
    Link qb = NULL;
    polynomail Pc;
    ElemType a, b, c;
    InitList(Pc);
    if (Pa.len != 0 && Pb.len != 0){
        qa = qa->next;
        while(qa){
            a = GetCurElem(qa);
            qb = GetHead(Pb);
            qb = qb->next;
            while(qb){
                b = GetCurElem(qb);
                c.coef = a.coef * b.coef;
                c.expn = a.expn + b.expn;
                OrderInsert(Pc, c, cmp);
                qb = qb->next;
            }
            qa = qa->next;
        }
        DestoryPolyn(Pb);
        ClearList(Pa);
        Pa.head = Pc.head;
        Pa.tail = Pc.tail;
        Pa.len = Pc.len;
    }
    else if(Pb.len==0){
        Pa = Pb;
    }
}
//----------------基本算法描述------------------------
int cmp(term a,term b){
    if (a.expn == b.expn)
        return 0;
    else
        return (a.expn - b.expn) / abs(a.expn - b.expn);
}

int main()
{
    polynomail A, B;
    cout << "请输入第一个多项式的项数为：";
    int length;
    cin >> length;
    CreatPolyn(A, length);
    cout << "PA(x) = ";
    ListTraverse(A, visit);
    cout << endl;
    cout << "请输入第二个多项式的项数为：";
    cin >> length;
    CreatPolyn(B, length);
    cout << "PB(x) = ";
    ListTraverse(B, visit);
    cout << endl;

    char m;
    cout << "请输入运算符号:";
    cin >> m;
    switch (m){
        case '+':
            AddPolyn(A, B);
            cout << "PA(x)+PB(x) = ";
            ListTraverse(A, visit);
            cout << endl;
            break;
        case '-':
            SubtractPolyn(A, B);
            cout << "PA(x)-PB(x) = ";
            ListTraverse(A, visit);
            cout << endl;
            break;
        case '*':
            MultiplyPolyn(A, B);
            cout << "PA(x)*PB(x) = ";
            ListTraverse(A, visit);
            cout << endl;
            break;
        default:
            cout << "请输入正确符号";
    }
    system("pause");
    return 0;
}


```
##【数据结构】【单链表逆置】
```
#include<iostream>
using namespace std;

typedef char datatype;
typedef struct node
{
	datatype data;
	struct node *next;
} Lnode, *linklist;

void creat(linklist &head)
{
	char ch;
	linklist s,r;
	head = new Lnode;
	r=head;
	while((ch=getchar())!='*')//到“ * ”结束
	{
		s = new Lnode;
		s->data=ch;
		r->next=s;
		r=s;
	}
	r->next=NULL;
}
void invert(linklist &head)
{
	linklist p, q, r;
	p=head->next;
	q=p->next;
	while(q!=NULL)
	{
		r=q->next;
		q->next=p;
		p=q;
		q=r;
	}
	head->next->next=NULL;
	head->next=p;
}
void print(linklist &head)
{
	linklist p=head->next;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}
int main()
{
	linklist head;
	creat(head);
	print(head);
	invert(head);
	print(head);
	return 0;
}
```
##【数据结构】【顺序表逆置】
```
#include <bits/stdc++.h>
using namespace std;

typedef char datatype;
const int maxsize = 1024;
typedef struct
{
    datatype data[maxsize];
    int last;
} SeqList, *PSeqList;

void creat(PSeqList &L)
{
    L = new SeqList;
    L->last = 0;
    char ch;
    while ((ch = getchar()) != '*')
    {
        L->data[L->last] = ch;
        L->last++;
    }
}

void invert(PSeqList &L)
{
    int n = L->last / 2;
    for (int i = 0; i < n; i++)
    {
        char temp = L->data[i];
        L->data[i] = L->data[L->last - i - 1];
        L->data[L->last - i - 1] = temp;
    }
}

void print(PSeqList &L)
{
    for (int i = 0; i < L->last; i++)
        cout << L->data[i] << " ";
    cout << endl;
}

int main()
{
    PSeqList L;
    creat(L);
    print(L);
    invert(L);
    print(L);
    return 0;
}
```
# 栈&队列
## 顺序栈&链式栈&迷宫求解&表达式求值-代码实现算法3.1-3.5
### 栈的顺序存储结构代码实现
```
#include<bits/stdc++.h>
using namespace std;
#define SElemType int
#define Status int
#define STACK_INIT_SIZE 100 
#define STACKINCREMENT  10    
//-------栈的顺序存储结构-----------------
typedef struct{
    SElemType *base;    //栈底
    SElemType *top;     //栈顶
    int stacksize;
} SqStack;

Status InitStack(SqStack &s){
    s.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!s.base)
        exit(_OVERFLOW);
    s.top = s.base;
    s.stacksize = STACK_INIT_SIZE;
    return 1;
}

Status DestoryStack(SqStack &s){
    free(s.base);
    s.base = NULL;
    s.top = NULL;
    s.stacksize = 0;
    return 1;
}

Status ClearStack(SqStack &s){
    if(!s.base)
        return 0;
    s.top = s.base;
    return 1;
}

Status StackEmpty(SqStack s){
    if(s.top==s.base)
        return 1;
    return 0;
}

int StackLength(SqStack s){
    if(!s.base)
        return 0;
    return (int)(s.top - s.base);
}

Status GetTop(SqStack s,SElemType &e){
    if(s.base==s.top)
        return 0;
    e = *(s.top - 1);
    return 1;
}

Status Push(SqStack &s,SElemType e){
    if(!s.base)
        return 0;
    if (s.top - s.base >= s.stacksize){
        s.base = (SElemType *)realloc(s.base, (s.stacksize + STACKINCREMENT) * sizeof(SElemType));
        if(!s.base)
            exit(_OVERFLOW);
        s.top = s.base + s.stacksize;
        s.stacksize += STACKINCREMENT;
    }
    *s.top++ = e;
    return 1;
}

Status Pop(SqStack &s,SElemType &e){
    if(!s.base||s.top==s.base)
        return 0;
    e = *--s.top;
    return 1;
}

void visit(SElemType e){
    cout << e << " ";
}

Status StackTraverse(SqStack s,void (*visit)(SElemType)){
    SElemType *p = s.base;
    if(!s.base)
        return 0;
    while (p < s.top)
        visit(*p++);
    cout << "\n";
    return 1;
}

//算法3.1
void conversion(){
    //进制转换
    SqStack S;
    InitStack(S);
    SElemType N, e;
    scanf("%d", &N);
    while(N){
        Push(S, N % 8);
        N /= 8;
    }
    while(!StackEmpty(S)){
        Pop(S, e);
        cout << e;
    }
}
// int main(){
//     conversion();
//     return 0;
// }

//算法3.2
void LineEdit(){
    SqStack S;
    InitStack(S);
    SElemType c;
    char ch = getchar();
    while (ch != EOF){
        while (ch != EOF && ch != '\n'){
            switch (ch){
                case '#':
                    Pop(S, c);
                    break;
                case '@':
                    ClearStack(S);
                    break;
                default:
                    Push(S, ch);
            }
            ch = getchar();
        }
        ClearStack(S);
        if (ch != EOF)
            ch = getchar();
    }
    DestoryStack(S);
}
// int main(){
//     LineEdit();
//     return 0;
// }

//算法3.3
//见后文

//算法3.4
//见后文

//算法3.5
int C = 0;
void move(char x, int n, char z) {
    cout << ++C << ". Move disk " << n << " from " << x << " to " << z << "."<<endl;
}
void hanoi(int n, char x, char y, char z) { 
    if (n == 1)
        move(x, 1, z);        //将编号为１的圆盘从x移到z
    else {
        hanoi(n - 1, x, z, y);
        move(x, n, z);        //将编号为n的圆盘从x移到z
        hanoi(n - 1, y, x, z);  //将y上编号为１至n-1的圆盘移到z,x作辅助塔
    }
}

//简单测试主函数
int main(){
    SqStack s;
	cout << "InitStack" << endl;
	InitStack(s);
	cout << "StackEmpty" << endl;
	StackEmpty(s) ? cout << "yes\n" : cout << "no\n";
	cout << "Push" << endl;
	for (int i = 1; i <= 6; i++)
		Push(s, i);
	cout << "StackTraverse" << endl;
	StackTraverse(s, visit);
	cout << "StackLength" << endl;
    cout << StackLength(s) << endl;
    cout << "Pop" << endl;
	SElemType e;
	Pop(s, e);
	cout << e << endl;
	StackTraverse(s, visit);
	cout << "GetTop" << endl;
	GetTop(s, e);
	cout << e << endl;

	return 0;
}




```
### 算法3.3 迷宫求解【顺序栈代码实现】
```
#include<bits/stdc++.h>
using namespace std;
#define Status int
#define STACK_INIT_SIZE 100 
#define STACKINCREMENT  10    
typedef int DirectiveType; //下一个通道方向
#define RANGE 100          //迷宫大小
#define ROW 10             //迷宫的行数
#define COL 10             //迷宫的列数
#define step ord
typedef struct{
    int m, n;
    int arr[RANGE][RANGE]; //迷宫数组
} MazeType; //迷宫的类型

typedef struct{
    int row; //迷宫中的行
    int col; //迷宫中的列
} PosType; //坐标(row,col)

typedef struct
{
    int ord; //当前位置在路径上的"序号"
    PosType seat; //当前的坐标位置
    int di; //往下一个坐标位置的方向
} SElemType; //栈的元素类型


typedef struct{
    SElemType *base;    //栈底
    SElemType *top;     //栈顶
    int stacksize;
} SqStack;

Status InitStack(SqStack &s){
    s.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!s.base)
        exit(_OVERFLOW);
    s.top = s.base;
    s.stacksize = STACK_INIT_SIZE;
    return 1;
}

Status DestoryStack(SqStack &s){
    free(s.base);
    s.base = NULL;
    s.top = NULL;
    s.stacksize = 0;
    return 1;
}

Status ClearStack(SqStack &s){
    if(!s.base)
        return 0;
    s.top = s.base;
    return 1;
}

Status StackEmpty(SqStack s){
    if(s.top==s.base)
        return 1;
    return 0;
}

int StackLength(SqStack s){
    if(!s.base)
        return 0;
    return (int)(s.top - s.base);
}

Status GetTop(SqStack s,SElemType &e){
    if(s.base==s.top)
        return 0;
    e = *(s.top - 1);
    return 1;
}

Status Push(SqStack &s,SElemType e){
    if(!s.base)
        return 0;
    if (s.top - s.base >= s.stacksize){
        s.base = (SElemType *)realloc(s.base, (s.stacksize + STACKINCREMENT) * sizeof(SElemType));
        if(!s.base)
            exit(_OVERFLOW);
        s.top = s.base + s.stacksize;
        s.stacksize += STACKINCREMENT;
    }
    *s.top++ = e;
    return 1;
}

Status Pop(SqStack &s,SElemType &e){
    if(!s.base||s.top==s.base)
        return 0;
    e = *--s.top;
    return 1;
}

Status StackTraverse(SqStack s,void (*visit)(SElemType)){
    SElemType *p = s.base;
    if(!s.base)
        return 0;
    while (p < s.top)
        visit(*p++);
    cout << "\n";
    return 1;
}
//-----------迷宫部分函数-------------
bool InitMaze(MazeType &maze, int a[ROW][COL], int row, int col)  //初始化迷宫
{
    int i, j;                            //设置迷宫maze的初值,包括加上边缘一圈的值
    for (i = 1; i<row - 1;i++){
       for (j = 1; j<col - 1; j++)
        {
           maze.arr[i][j] = a[i][j];
        }
    }                                          
    for (j = 0; j<row; j++)                     //加上围墙
        maze.arr[0][j] = maze.arr[row - 1][j] = 1;
    for (i = 0; i<col; i++)
        maze.arr[i][0] = maze.arr[i][col - 1] = 1;
    return true;
}

bool Pass(MazeType maze, PosType curpos){             //判断当前节点是否通过                                    
    if (maze.arr[curpos.row][curpos.col]== 0)     //当节点为0时返回真
       return true;
    else
       return false;
}

bool FootPrint(MazeType &maze, PosType curpos){       //留下足迹

    maze.arr[curpos.row][curpos.col] = 2; //走过且走得通
    return true;
}

bool MarkPrint(MazeType &maze, PosType curpos){     //留下不能通过的标记
    maze.arr[curpos.row][curpos.col] = 3;        //走过但走不通
    return true;
}

SElemType CreateSElem(int step, PosType pos, int di){           //创建元素e         
    SElemType e;
    e.step = step;
    e.seat = pos;
    e.di = di;
    return e;
}

PosType NextPos(PosType curpos, DirectiveType di){  //curpos当前位置           //返回当前节点的下一节点                                     
    PosType pos = curpos;
    switch (di){
        case 1:        //右
            pos.col++;
            break;
        case 2:        //下
            pos.row++;
            break;
        case 3:        //左
            pos.col--;
            break;
        case 4:        //上
            pos.row--;
            break;
        }
    return pos;
}

bool PosEqual(PosType pos1, PosType pos2){              //判断是不是出口                                 
    if (pos1.row == pos2.row&& pos1.col == pos2.col)    
       return true;                            
    else
       return false;
}

void PrintMaze(MazeType maze, int row, int col){      //打印路径                                         
    int i, j;
    printf(" ");
    for (i = 0; i<col; i++)                    //打印列数名
       printf("%d ", i);
    printf("\n");
    for (i = 0; i<row; i++){
       printf("%d",i);                      //打印行数名
       for (j = 0; j<col; j++){
            switch (maze.arr[i][j]){
                case 0:
                    printf("  ");                 //没走过，但是通路
                    break;
                case 1:
                    printf("■");                  //墙，障碍物
                    break;
                case 2:
                    printf("*");
                    break;
                case 3:
                    printf("@"); 
                    break;
                default:
                    break;
           }
       }
       printf("\n");
    }
}

Status MazePath(MazeType &maze, PosType start, PosType end){ //求解迷宫maze中,从入口start到出口end的一条路径
    SqStack s;                  //定义栈
    SElemType e;            
    InitStack(s);               //初始化栈
    PosType curpos = start;             
    int curstep = 1;                                //探索第一步
    do {
        if (Pass(maze, curpos)){    //如果当前位置可以通过,即是未曾走到的通道块
            FootPrint(maze,curpos);                //留下足迹
            e = CreateSElem(curstep,curpos, 1);    //创建元素
            Push(s, e);                             //加入路径
            if (PosEqual(curpos,end))              //到达终点（出口）
                return true;                        
            curpos = NextPos(curpos,1);            //获得下一节点
                return true;                        
            curstep++;                              //探索下一步
        }
        else{       //当前位置不能通过
            if (!StackEmpty(s)){
                Pop(s, e);
                while (e.di == 4&& !StackEmpty(s)){ //找寻了四个方向      
                    MarkPrint(maze,e.seat);
                    Pop(s, e);                      //留下不能通过的标记,并退回一步
                }
                if (e.di<4){
                    e.di++;                         //换一个方向探索
                        Push(s, e);
                    curpos =NextPos(e.seat, e.di); //设定当前位置是该方向上的相邻块
                }
            }
        }
    } while (!StackEmpty(s));
    return 0;
}
```
### 算法3.4 表达式求值【链式栈代码实现】
```
#include<bits/stdc++.h>
using namespace std;
#define SElemType char
#define Status int
typedef char OperandType;

// -----栈的链式存储结构----------------------------------
typedef struct SNode {
    SElemType data;                 // 数据域
    struct SNode *next;             // 指针域
} SNode, *LinkStack;


Status InitStack(LinkStack &S) {
    S = (LinkStack)malloc(sizeof(SNode));
    if(!S)                          // 存储分配失败
        exit(_OVERFLOW);             // exit(-2)程序异常退出
    S->next = NULL;
    return 1;
}
 
// 操作结果：销毁栈S，S不再存在。
Status DestroyStack(LinkStack &S) {
    LinkStack p = S->next, ptmp;    // p指向栈顶
    while(p) {                      // p指向栈底时，循环停止
        ptmp = p->next;
        free(p);                    // 释放每个数据结点的指针域
        p = ptmp;
    }
    free(S);
    return 1;
}
 
// 操作结果：把S置为空栈。
Status ClearStack(LinkStack &S) {
    LinkStack p = S->next, ptmp;    // p指向栈顶
    while(p) {                      // p指向栈底时，循环停止
        ptmp = p->next;
        free(p);                    // 释放每个数据结点的指针域
        p = ptmp;
    }
    S->next = NULL;
    return 1;
}
 
// 操作结果：若S为空栈，返回TRUE，否则返回FALSE
Status StackEmpty(LinkStack S) {
    if(S->next == NULL)
        return 1;           
    else
        return 0;      
}
 
// 操作结果：返回S的元素个数，即栈的长度。
int StackLength(LinkStack S) {
    int n = 0;
    LinkStack p = S->next;          // p指向栈顶
    while(p) {
        n++;
        p = p->next;
    }
    return n;
}
 
// 操作结果：若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR。
Status GetTop(LinkStack S, SElemType &e) {
    if ( S->next == NULL )
        return 0;
    e = S->next->data;     // 取栈顶元素
    return 1;
}
 
// 操作结果：插入元素e为新的栈顶元素。
Status Push(LinkStack &S, SElemType e) {
    LinkStack p = (LinkStack)malloc(sizeof(SNode));
    p->data = e;
    p->next = S->next;              // 新结点指向栈顶
    S->next = p;                    // 更新栈顶指针
//  printf("插入的栈顶元素：");  visit(e);
    return 1;
}// Push
 
// 操作结果：若栈不空，则删除S的栈顶元素，并用e返回其值；否则返回ERROR。
Status Pop(LinkStack &S, SElemType &e) {
    // 若1个元素也没有：
    if (S->next == NULL)
        return 0;
    // 若有1个以上元素
    e = S->next->data;
    LinkStack ptmp = S->next->next;
    free(S->next);
    S->next = ptmp;
//  printf("删除的栈顶元素：");  visit(e);
    return 1;
}// Pop
 
 
Status visit(SElemType e) {
    printf(" %c\n", e);
    return 1;
}

// 操作结果：从 栈底到栈顶 依次对栈中每个数据元素调用函数visit()。一旦vistit()失败，刚操作失败。
Status StackTraverse(LinkStack S, Status (*visit)(SElemType)) {
    if(S->next == NULL){
        printf("栈为空!\n");
        return 0;
    }
    for(int i=StackLength(S); i>0; i--){
        LinkStack p = S->next;      // p指向栈顶
        int j = 1;                  // j为计数器
        while ( p && j<i ) {        // 顺指针向后查找，直到p指向第i个元素或p为空
            p = p->next;
            ++j;
        }
        visit(p->data);
    }
    printf("\n");
    return 1;
}

// 操作结果：从 栈顶到栈底 依次对栈中每个数据元素调用函数visit()。一旦vistit()失败，刚操作失败。
Status StackTraverse_Top(LinkStack S, Status (*pfn_visit)(SElemType)) {
    if(S->next == NULL){
        printf("栈为空!\n");
        return 0;
    }
    LinkStack p = S->next;          // p指向栈顶
    while(p) {
        visit(p->data);
        p = p->next;
    }
    printf("\n");
    return 1;
}
 
//----------------------算法部分------------------------------
// 判定运算符栈的（栈顶运算符θ1）与（读入的运算符θ2）之间的优先关系
SElemType Precede(SElemType t1, SElemType t2){
    SElemType t;
    switch (t1){
        case '+':
        case '-':
            if(t2=='*' || t2=='/' || t2=='(')
                t = '<';
            else t = '>';
            break;
        case '*':
        case '/':
            if(t2 == '(')
                t = '<';
            else t = '>';
            break;
        case '(':
            if(t2 == ')')
                t = '=';
            else if(t2 == '#')
                return 0;
            else t = '<';
            break;
        case ')':
            if(t2 == '(')
                return 0;
            else t = '>';
            break;
        case '#':
            if(t2 == ')')
                return 0;
            else if(t2 == '#')
                t = '=';
            else t = '<';
            break;
    }
    return t;
}

// 进行二元运算 a θ b
SElemType Operator(SElemType a, SElemType theta, SElemType b){ 
    SElemType ret;
    switch(theta){
        case '+':
            ret = (a-48) + (b-48) + 48;
            break;
        case '-':
            ret = (a-48) - (b-48) + 48;
            break;
        case '*':
            ret = (a-48) * (b-48) + 48;
            break;
        case '/':
            ret = (a-48) / (b-48) + 48;
            break;
    }
    return ret;
}
 
Status In(SElemType c){ 
    switch(c){
        case '+':
        case '-':
        case '*':
        case '/':
        case '(':
        case ')':
        case '#':
        case '=':
            return 1;
            break;
        default:
            return 0;
    }
}
//算法3.4
OperandType ExvaluateExpression()
{ // 算术表达式求值的算符优先算法。设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合。
    LinkStack OPTR;                // 运算符栈：寄存运算符
    LinkStack OPND;                // 运算数栈：寄存操作数或运算结果
    char c, x, theta, a, b, e;
 
    InitStack(OPTR);
    InitStack(OPND);
    Push(OPTR, '#');                // 表达式起始符“#”为运算符栈的栈底元素
    printf("输入表达式:\n");
    c = getchar();
    GetTop(OPTR, e);
    while (c!='#' || e!='#'){        // 当前读入的字符 或 运算符栈顶元素不为‘#’号
        if (!In(c)) {                // 不是运算符(操作数、结果)则进栈
            Push(OPND, c);
            c = getchar();
        }
        else{                        // 是运算符，则和运算符栈顶的运算符比较优先级 
            GetTop(OPTR, e);
            switch (Precede(e, c)){
                case '<':           // 栈顶元素优先权低
                    Push(OPTR, c);
                    c = getchar();
                    break;
                case '=':           // 脱括号并接收下一字符
                    Pop(OPTR, x);
                    c = getchar();
                    break;
                case '>':           // 退栈并将运算结果入栈
                    Pop(OPTR, theta);
                    Pop(OPND, b);
                    Pop(OPND, a);
                    Push(OPND, Operator(a, theta, b));
                    break;
            }
        }
        GetTop(OPTR, e);
    }
    GetTop(OPND, e);
    return e;
}
 
int main(){
    // 3*(7-2)#=15
    char c;
    do {
        fflush(stdin);      //清空缓冲区
        c = ExvaluateExpression();
        printf("表达式的值:");
        printf("%d\n", c-48);
        printf("是否继续(y/n):");
    } while(scanf("%s", &c)!=0 && (c=='y' || c=='Y'));
    return 0;
}

```
## 链队列
```
#include<bits/stdc++.h>
using namespace std;
#define QElemType int
#define Status int
//---------链队列实现--------------
typedef struct QNode{
    QElemType data;
    struct QNode *next;
} QNode, *QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
} LinkQueue;
//----------基本操作----------------
Status InitQueue(LinkQueue &Q){
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    if (!Q.front)
        exit(_OVERFLOW);
    Q.front->next = NULL;
    return 1;
}

Status DestroyQueue(LinkQueue &Q){
    while (Q.front){
        Q.rear = Q.front->next;
        free(Q.front);
        Q.front = Q.rear;
    }
    return 1;
}

Status ClearQueue(LinkQueue &Q){
    QueuePtr p, q;
    Q.rear = Q.front;
    p = Q.front->next;
    Q.front->next = NULL;
    while (p){
        q = p;
        p = p->next;
        free(q);
    }
    return 1;
}

Status QueueEmpty(LinkQueue Q){
    if (Q.front == Q.rear)
        return 1;
    else
        return 0;
}

int QueueLength(LinkQueue Q){
    int i = 0;
    QueuePtr p;
    p = Q.front;
    while (Q.rear != p){
        i++;
        p = p->next;
    }
    return i;
}

Status GetHead(LinkQueue Q, QElemType &e){
    QueuePtr p;
    if (Q.front == Q.rear)
        return 0;
    p = Q.front->next;
    e = p->data;
    return 1;
}

Status EnQueue(LinkQueue &Q, QElemType e){
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
    if (!p)
        exit(_OVERFLOW);
    p->data = e;
    p->next = NULL;
    Q.rear->next = p; 
    Q.rear = p;    
    return 1;
}

Status DeQueue(LinkQueue &Q, QElemType &e){
    QueuePtr p;
    if (Q.front == Q.rear)
        return 0;
    p = Q.front->next;   
    e = p->data;           
    Q.front->next = p->next; 
    if (Q.rear == p)  
        Q.rear = Q.front;
    free(p);
    return 1;
}

void visit(QElemType a){
    cout << a << " ";
}
Status QueueTraverse(LinkQueue &Q,void (*visit)(QElemType)){
    QueuePtr p;
    p = Q.front->next;
    while (p){
        visit(p->data);
        p = p->next;
    }
    cout<<endl;
    return 1;
}

```
## 循环队列
```
#include<bits/stdc++.h>
using namespace std;
#define QElemType int
#define Status int
#define MAXQSIZE 10
//----------循环队列------------
typedef struct{
    QElemType *base;
    int front;
    int rear;
} SqQueue;
//----------函数申明------------
Status InitQueue(SqQueue &Q);
Status DestroyQueue(SqQueue &Q);
Status ClearQueue(SqQueue &Q);
Status QueueEmpty(SqQueue Q);
Status QueueLength(SqQueue Q);
Status GetHead(SqQueue &Q, QElemType &e);
Status EnQueue(SqQueue &Q, QElemType e);
Status DeQueue(SqQueue &Q, QElemType &e);
void visit(QElemType a);
Status QueueTraverse(SqQueue &Q, void (*visit)(QElemType));
//----------基本操作------------
Status InitQueue(SqQueue &Q) {
    Q.base = (QElemType *)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q.base)
        exit(_OVERFLOW);
    Q.front = Q.rear = 0;
    return 1;
}

Status DestroyQueue(SqQueue &Q){
    while(!QueueEmpty(Q)){
        free(&Q.base[Q.front]);
        Q.front = (Q.front + 1) % MAXQSIZE;
    }
}

Status ClearQueue(SqQueue &Q){
    if(QueueEmpty(Q))
        return 0;
    QElemType i = QueueLength(Q);
    while(i--){
        Q.base[Q.front] = 0;
        Q.front = (Q.front + 1) % MAXQSIZE;
    }
    Q.front = Q.rear = 0;
    return 1;
}

Status QueueEmpty(SqQueue Q){
	if(Q.front==Q.rear)
        return 1;
    else
        return 0;
}

Status QueueLength(SqQueue Q){
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}


Status GetHead(SqQueue &Q,QElemType &e)
{
	if(Q.front==Q.rear)
        return 0;
    e=Q.base[Q.front];
	return 1;
}

Status EnQueue(SqQueue &Q,QElemType e){
    if ((Q.rear + 1) % MAXQSIZE == Q.front)
        return 0;
    Q.base[Q.rear]=e;
    Q.rear = (Q.rear + 1) % MAXQSIZE;
    return 1; 
}

Status DeQueue(SqQueue &Q,QElemType &e){
	if(Q.front==Q.rear)
        return 0;
    e=Q.base[Q.front];					
	Q.front=(Q.front+1)%MAXQSIZE;		
	return 1;
}

void visit(QElemType a){
    cout << a << " ";
}
Status QueueTraverse(SqQueue &Q,void (*visit)(QElemType)){
    if(QueueEmpty(Q)){
        cout << "The queue is empty!\n";
    }
    else{
        for (int i = Q.front; i != Q.rear; i = (i + 1) % MAXQSIZE)
            visit(Q.base[i]);
        cout << endl;
    }
    return 1;
}

int main(){
    SqQueue Q;
    QElemType e;
    InitQueue(Q);
    cout << "是否为空：" << QueueEmpty(Q) << endl;
    for (int i = 0; i < 8;i++){
        EnQueue(Q, i);
    }
    cout << "队列元素的个数：" << QueueLength(Q)<<endl;
    QueueTraverse(Q, visit);
    cout << "出对的元素为：";
    for (int i = 0; i < 4;i++){
        DeQueue(Q, e);
        cout << e << " ";
    }
    cout << endl;
    cout << "是否为空：" << QueueEmpty(Q) << endl;
    cout << "队列元素的个数：" << QueueLength(Q)<<endl;
    for (int i = 8; i < 12;i++){
        EnQueue(Q, i);
    }
    cout << "队列元素的个数：" << QueueLength(Q)<<endl;
    QueueTraverse(Q, visit);
    GetHead(Q, e);
    cout << "输出队头:" << e << endl;
    ClearQueue(Q);
    cout << "队列元素的个数：" << QueueLength(Q)<<endl;
    cout << "是否为空：" << QueueEmpty(Q) << endl;

}
```
# 串
## 串的定长顺序存储表示-代码实现算法4.1-4.3实现
```
#include<bits/stdc++.h>
using namespace std;
#define Status int
//--------------串的定长顺序存储表示-------------------
#define MAXSTRLEN 255
typedef unsigned char SString[MAXSTRLEN + 1];			//0号单元存放串的长度
 
Status StrAssign(SString &T, const char *chars) {
	int len, uncut;
	int i;
	len = strlen(chars);
	if (len > MAXSTRLEN) {
		T[0] = MAXSTRLEN;
		uncut = 0;
	}
	else {
		T[0] = len;
		uncut = 1;
	}
	for(i = 1; i <= T[0]; i++) {
		T[i] = chars[i - 1];
	}
	return uncut;
}
 
Status StrCopy(SString &T, SString S) {
	if (S == NULL)
		return 0;
	for(int i = 0; i <= S[0]; i++)
		T[i] = S[i];				//最后一位'\0'
	return 1;
}
 
Status StrEmpty(SString S) {
	if (S == NULL)
		return 0;
	if (S[0] == 0)
		return 1;
	else
		return 0;
}
 
Status StrCompare(SString S, SString T) {
	if (S && T == NULL)
		return 0;
	for(int i = 1; i <= S[0] && i <= T[0]; i++) {
		if (S[i] != T[i])
			return S[i] - T[i];
	}
	return S[0] - T[0];
}
 
Status StrLength(SString S) {
	//串S存在，返回S的元素个数
	if (S == NULL)
		return 0;
	return S[0];
}
 
Status ClearString(SString &S) {
	//串S存在，将S清为空串
	if (S == NULL) 
		return 0;
	S[0] = 0;
	return 1;
}
//算法4.2
Status Concat(SString &T, SString S1, SString S2) {
	int i, j;
	int uncut;
	if (S1 && S2 == NULL)
		return 0;
	if (S1[0] + S2[0] <= MAXSTRLEN) {
		for (i = 1; i <= S1[0]; i++)
			T[i] = S1[i];
		for (i = S1[0] + 1, j = 1; i <= S1[0] + S2[0], j <= S2[0]; i++, j++)
			T[i] = S2[j];
		T[0] = S1[0] + S2[0];
		uncut = 1;
	}
	else if (S1[0] < MAXSTRLEN) {
		for(i = 1; i <= S1[0]; i++)
			T[i] = S1[i];
		for(i = S1[0] + 1, j = 1; i <= MAXSTRLEN, j <= MAXSTRLEN - S1[0]; i++, j++) 
			T[i] = S2[j];
		T[0] = MAXSTRLEN;
		uncut = 0;
	}
	else {
		for(i = 0; i <= MAXSTRLEN; i++)
			T[i] = S1[i];
		uncut = 0;
	}
	return uncut;
}
//算法4.3
Status SubString(SString &Sub, SString S, int pos, int len) {
	if (pos < 1 || pos > S[0] || len < 0 || len > S[0] - pos + 1)
		return 0;
	int i, j;
	for(i = 1, j = pos; i <= len, j <= pos + len -1; i++, j++)
		Sub[i] = S[j];
	Sub[0] = len;
	return 1;
}
//算法4.1
Status Index(SString S, SString T, int pos) {
	int n, m, i;
	if (pos > 0) {
		n = StrLength(S);
		m = StrLength(T);
		i = pos;
		SString sub;
		while(i <= n - m + 1) {
			SubString(sub, S, i, m);
			if (StrCompare(sub, T) != 0)
				i++;
			else
				return i;	//返回子串在主串中的位置
		}
	}
	return 0;				//S中不存在与T相等的子串
}
 
Status Replace(SString &S, SString T, SString V) {
	int i = 1;
	if (StrEmpty(T))
		return 0;
	while(i) {
		i = Index(S, T, i);
		if (i) {
			StrDelete(S, i, T[0]);
			StrInsert(S, i, V);
			i += V[0];
		}
	}
	return 1;
}

Status StrInsert(SString &S, int pos, SString T) {
	if ((S && T == NULL) || (pos < 1) || (pos > S[0] + 1))
		return 0;
	int uncut;
	int i;
	if (S[0] + T[0] <= MAXSTRLEN) {
		for(i = S[0]; i >= pos; i--)
			S[i + T[0]] = S[i];
		for(i = pos; i < pos + T[0]; i++)
			S[i] = T[i - pos + 1];
		S[0] += T[0];
		uncut = 1;
	}
	else {
		for(i = MAXSTRLEN; i >= pos; i--)
			S[i] = S[i - T[0]];
		for(i = pos; i < pos + T[0]; i++)
			S[i] = T[i - pos + 1];
		S[0] = MAXSTRLEN;
		uncut = 0;
	}
}
 
Status StrDelete(SString &S, int pos, int len) {
	if ((S == NULL) || (pos < 1) || (pos > S[0] - len + 1) || (len < 0))
		return 0;
	int i;
	for(i = pos; i <= pos + len; i++)
		S[i] = S[i + len];
	S[0] -= len;
	return 1;
}
 
Status DestroyString (SString &S) {
	return 0;
}

```
## 串的堆分配存储表示-代码实现算法4.4实现
```
#include<bits/stdc++.h>
using namespace std;
#define Status int
//---------串的堆分配存储表示--------------------
typedef struct{
	char *ch;//按照需要分配内存
	int length;//串长度
}HString;
//---------基本操作的函数原型说明-----------------
Status StrAssign(HString &T,char *chars){
	int i;				//i为chars的长度
	char *c;
    for (i = 0, c = chars; *c; i++, c++);
    if (!i){
        T.ch = NULL;
        T.length = 0;
    }
	else{
        T.ch = (char *)malloc(sizeof(char) * i);
        if (!T.ch)
            exit(_OVERFLOW);
        int tempi = 0;
        char *head = T.ch;
        do
        {
            tempi++;
            *T.ch = *chars;
            T.ch++;
            chars++;

        } while (tempi != i);
        T.ch = head;
        T.length = i;
        return 1;
	}
}

Status StrLength(HString S){
	return S.length;
}

Status StrCompare(HString S,HString T){
    for (int i = 0; i < S.length && i < T.length; i++)
        if (S.ch[i] != T.ch[i])
            return S.ch[i] - T.ch[i];
    return S.length - T.length;
}

Status ClearString(HString &S){
	if(S.ch){
        free(S.ch);
        S.ch = NULL;
    }
    S.length = 0;
    return 1;
}

Status Concat(HString &T,HString S1,HString S2)
{
	if (T.ch){
		free(T.ch);
	}
    T.length = StrLength(S1) + StrLength(S2);
    T.ch = (char *)malloc(sizeof(char) * T.length);
    if (!T.ch){
        exit(_OVERFLOW);
    }
    char *head = T.ch;
    for (int i = 0; i < StrLength(S1); i++){
        *T.ch = *S1.ch;
        T.ch++;
        S1.ch++;
	}
    for (int i = StrLength(S1) - 1; i < T.length; i++){
        *T.ch = *S2.ch;
        T.ch++;
		S2.ch++;
	}
    T.ch = head;
    return 1;
}

Status SubString(HString &Sub,HString S,int pos,int len){
    if (pos < 1 || pos > S.length || len < 0 || len > S.length - pos + 1)
        return 0;
    if (Sub.ch)
        free(Sub.ch);
    if (!len){
        Sub.ch = NULL;
        Sub.length = 0;
        return 1;
    }else{
        Sub.ch = (char *)malloc(sizeof(char) * len);
        Sub.length = len;
        char *head = Sub.ch;
        S.ch += pos - 1;
        for (int i=0;i<len;i++){
            *Sub.ch = *S.ch;
            Sub.ch++;
			S.ch++;
        }
        Sub.ch = head;
        return 1;
    }
}
//算法4.4
Status StrInsert(HString &S,int pos,HString T){
    int i;
    if (pos < 1 || pos > S.length + 1)
        return 0;
    if(T.length){
        if(!(S.ch=(char*)realloc(S.ch,(S.length+T.length)*sizeof(char))))
            exit(_OVERFLOW);
        for (i = S.length - 1; i >= pos - 1;i--)
            S.ch[i + T.length] = S.ch[i];
        for (i = 0; i <= T.length - 1; i++)
            S.ch[i + pos - 1] = T.ch[i];
        S.length += T.length;
    }
    return 1;
}

void prinfStr(HString S)
{
	for (int i=0;i<S.length;i++)
	{
		printf("%c",*S.ch);
		S.ch++;
	}
	printf("\n");
}
```
# 二叉树
##  二叉树基本实现
```
#include <bits/stdc++.h>
using namespace std;
#define TElemType char
#define Status int
//------------二叉树的二叉链表存储表示-------------
typedef struct BiTNode
{
    TElemType data;
    struct BiTNode *lchild, *rchild; //左右孩子指针
} BiTNode, *BiTree;

//------------基本操作的函数原型说明---------------
Status InitBiTree(BiTree &T);
Status DestroyBiTree(BiTree &T);
Status CreateBiTree(BiTree &T);
void ClearBiTree(BiTree &T);
Status BiTreeEmpty(BiTree T);
int BiTreeDepth(BiTree T);
Status Root(BiTree T);
Status Value(BiTree T, TElemType e);
Status Assign(BiTree &T, TElemType e, TElemType value);
Status Parent(BiTree T, TElemType e);
Status LeftChild(BiTree T, TElemType e);
Status RightChild(BiTree T, TElemType e);
Status LeftSibling(BiTree T, TElemType e);
Status RightSibling(BiTree T, TElemType e);
Status InsertChild(BiTree T, BiTree p, int LR, BiTree c);
Status DeleteChild(BiTree T, BiTree p, int LR);
//-----------------具体实现-----------------------
Status InitBiTree(BiTree &T){
    T = NULL;
    return 1;
}

Status DestroyBiTree(BiTree &T){
    if ((T)->lchild)             
        DestroyBiTree(T->lchild); 
    if ((T)->rchild)                 
        DestroyBiTree(T->rchild); 
    free(T);                        
    T = NULL;
    return 1;
}

Status CreateBiTree(BiTree &T){ 
    //算法6.4
    TElemType ch;
    scanf("%c", &ch);
    if (ch == ' ') 
        T = NULL;
    else
    {
        T = (BiTree)malloc(sizeof(BiTNode));
        if (!T)
            exit(_OVERFLOW);
        T->data = ch;             
        CreateBiTree(T->lchild); 
        CreateBiTree(T->rchild);
    }
    return 1;
}

void ClearBiTree(BiTree &T){
    if (T){
        if ((T)->lchild)             
            ClearBiTree(T->lchild); 
        if ((T)->rchild)                 
            ClearBiTree(T->rchild); 
        free(T);                        
        T = NULL;                
    }
}

Status BiTreeEmpty(BiTree T){
    if (T)
        return 0;
    else
        return 1;
}

int BiTreeDepth(BiTree T){
    int i, j;
    if (!T)
        return 0;
    if (T->lchild)
        i = BiTreeDepth(T->lchild);
    else
        i = 0;
    if (T->rchild)
        j = BiTreeDepth(T->rchild);
    else
        j = 0;
    return i > j ? i + 1 : j + 1;
}

Status Root(BiTree T){
    cout << T->data << endl;
    return 1;
}

Status Value(BiTree T,TElemType e){
    if(T->data==e)
        return 1;
    else{
        int i = 0, j = 0;
        if(T->lchild)
            i = Value(T->lchild, e);
        if(T->rchild)
            j = Value(T->rchild, e);
        if(i||j)
            return 1;
        else
            return 0;
    }
    return 0;
}

Status Assign(BiTree &T,TElemType e,TElemType value){
	if(T->data==e){
        T->data = value;
        return 1;
	}
	else{
		int i=0,j=0;
		if(T->lchild){
            i = Assign(T->lchild, e, value);
        }
		if(T->rchild){
			j=Assign(T->rchild,e,value);
		}
		if(i||j) return 1;
		else return 0;
	}
	return 0;
}

Status Parent(BiTree T,TElemType e){
	if(T->lchild&&T->lchild->data==e){
		printf("双亲节点为：%c\n",T->data);
	    return 1;
	}
	else if(T->rchild&&T->rchild->data==e){
		printf("双亲节点为：%c\n",T->data);
	    return 1;
	}
	else{
		if(T->lchild){
			Parent(T->lchild,e);
		}
		if(T->rchild){
			Parent(T->rchild,e);
		}
	}
	return 0;
}

Status LeftChild(BiTree T,TElemType e){
	if(T->data==e&&T->lchild){
		printf("左孩子节点为：%c\n",T->lchild->data);
		return 1;
	}
	else{
		if(T->lchild){
			LeftChild(T->lchild,e);
		}
		if(T->rchild){
			LeftChild(T->rchild,e);
		}
	}
	return 0;
}

Status RightChild(BiTree T,TElemType e){
	if(T->data==e&&T->rchild){
		printf("右孩子节点为：%c\n",T->rchild->data);
		return 1;
	}
	else{
		if(T->lchild){
			RightChild(T->lchild,e);
		}
		if(T->rchild){
			RightChild(T->rchild,e);
		}
	}
	return 0;
}

Status LeftSibling(BiTree T,TElemType e){
	if(T->lchild&&T->rchild->data==e){
		printf("左兄弟节点为：%c\n",T->lchild->data);
		return 1;
	}
	else{
		if(T->lchild){
			LeftSibling(T->lchild,e);
		}
		if(T->rchild){
			LeftSibling(T->rchild,e);
		}
	}
	return 0;
}

Status RightSibling(BiTree T,TElemType e){
	if(T->rchild&&T->lchild->data==e){
		printf("左兄弟节点为：%c\n",T->rchild->data);
		return 1;
	}
	else{
		if(T->lchild){
			RightSibling(T->lchild,e);
		}
		if(T->rchild){
			RightSibling(T->rchild,e);
		}
	}
	return 0;
}

Status InsertChild(BiTree T,BiTree p,int LR,BiTree c){
	if(LR==0){//c的右子树为空，使p的左子树成为c的右子树，并使增加了右子树的c成为p的左子树 
		c->rchild=p->lchild;
		p->lchild=c;
	}
	else{//c的右子树为空，使p的右子树成为c的右子树，并使增加了右子树的c成为p的右子树 
		c->rchild=p->rchild;
		p->rchild=c;
	}
	return 1; 
}

Status DeleteChild(BiTree T,BiTree p,int LR){
	if(LR==0){//删除p的左子树 
		DestroyBiTree(p->lchild); 
	}
	else{//删除p的右子树 
		DestroyBiTree(p->rchild);
	}
	return 1; 
}

```
## 二叉树的前/中/后/递归/非递归遍历&层序遍历-代码实现算法6.1-6.4
```
#define SElemType BiTree
// -----栈的链式存储结构----------------------------------
typedef struct SNode {
    SElemType data;                 // 数据域
    struct SNode *next;             // 指针域
} SNode, *LinkStack;


Status InitStack(LinkStack& S)
{
	S = (LinkStack)malloc(sizeof(SNode));
	if (!S)
		return 0;
	S->next = NULL;
}

Status DestroyStack(LinkStack& S)
{
	LinkStack p = S->next, ptmp;
	while (p) {
		ptmp = p->next;
		free(p);
		p = ptmp;
	}
	free(S);
	return 1;
}

Status ClearStack(LinkStack& S)
{
	LinkStack p = S->next, ptmp;
	while (p) {
		ptmp = p->next;
		free(p);
		p = ptmp;
	}
	S->next = NULL;
	return 1;
}

Status StackEmpty(LinkStack& S)
{
	return S->next == NULL;
}

int StackLength(LinkStack S)
{
	int ans = 0;
	LinkStack p = S->next;
	while (p) {
		ans++;
		p = p->next;
	}
	return ans;
}

Status GetTop(LinkStack S, SElemType& e)
{
	if (S->next == NULL)
		return 0;
	e = S->next->data;
	return 1;
}

Status Push(LinkStack& S, SElemType e)
{
	SNode* p = (SNode*)malloc(sizeof(SNode));
	p->data = e;
	p->next = S->next;
	S->next = p;
	return 1;
}

Status Pop(LinkStack& S, SElemType& e)
{
	if (S->next == NULL)
		return 0;
	e = S->next->data;
	SNode* p = S->next;
	S->next = p->next;
	free(p);
	return 1;
}

Status Visit(TElemType e){
    cout << e << " ";
    return 1;
}

```
### 二叉树的前序遍历
* 递归版
```
Status Visit(TElemType e){
    cout << e;
    return 1;
}
//先序遍历
//算法6.1
Status PreOrderTraverse(BiTree T,Status Visit(TElemType e)){
    if(T){
        Visit(T->data);
        PreOrderTraverse(T->lchild, Visit);
        PreOrderTraverse(T->rchild, Visit);
    }
}
```
* 非递归版
```
//先序遍历
Status PreOrderTraverse1(BiTree T,Status Visit(TElemType e))
{
	if (T == NULL)
		return 0;
    BiTree p;
    LinkStack s;
    InitStack(s);
    Push(s, T);//根进栈
    while (!StackEmpty(s))
	{
		while(GetTop(s,p) && p){
            if(!Visit(p->data))
                return 0;
            Push(s, p->lchild); //左走到尽头
		}
        Pop(s, p);  //空指针退栈
        if(!StackEmpty(s)){//访问结点
            Pop(s, p);
            Push(s, p->rchild);
        }
    return 1;
}
Status PreOrderTraverse2(BiTree T,Status Visit(TElemType e))
{
	if (T == NULL)
		return 0;
    BiTree p = T, e;
    LinkStack s;
    InitStack(s);
    while (p || !StackEmpty(s))
	{
        if(p){          //根指针进栈，遍历左子树
            if(!Visit(p->data))
                return 0;
            Push(s, p);
            p = p->lchild;
        }else{          //根指针退栈，访问根结点，遍历右子树
            Pop(s, p);
            p = p->rchild;
        }
	}
    return 1;
}
```

### 中序遍历
* 递归版
```
//中序遍历
Status InOrderTraverse(BiTree T,Status Visit(TElemType e)){
    if(T!=NULL){
	    InOrderTraverse(T->lchild, Visit);
	    Visit(T->data);
	    InOrderTraverse(T->rchild, Visit);
	}
}
```
*非递归版
```
//中序非递归实现
//算法6.2
Status InOrderTraverse1(BiTree T,Status Visit(TElemType e))
{
	if (T == NULL)
		return 0;
    BiT.ree p;
    LinkStack s;
    InitStack(s);1
    Push(s, T);//根进栈
    while (!StackEmpty(s))
	{
		while(GetTop(s,p) && p){
            Push(s, p->lchild); //左走到尽头
		}
        Pop(s, p);  //空指针退栈
        if(!StackEmpty(s)){//访问结点
            Pop(s, p);
            if(!Visit(p->data))
                return 0;
            Push(s, p->rchild);
        }
	}/
    return 1;
}
//算法6.3
Status InOrderTraverse2(BiTree T,Status Visit(TElemType e))
{
	if (T == NULL)
		return 0;
    BiTree p = T, e;
    LinkStack s;
    InitStack(s);
    while (p || !StackEmpty(s))
	{
        if(p){          //根指针进栈，遍历左子树
            Push(s, p);
            p = p->lchild;
        }else{          //根指针退栈，访问根结点，遍历右子树
            Pop(s, p);
            if(!Visit(p->data))
                return 0;
            p = p->rchild;
        }
	}
    return 1;
}
```
### 后序遍历
*递归版
```
//后序遍历
Status PostOrderTraverse(BiTree T,Status Visit(TElemType e)){
    if(T!=NULL){
	    PostOrderTraverse(T->lchild, Visit);
	    PostOrderTraverse(T->rchild, Visit);
        Visit(T->data);
    }
}
```
* 非递归版
```
//后序非递归
Status PostOrderrTraverse2(BiTree T, Status(*Visit)(TElemType e))
{
	if (T == NULL)
		return 0;
	BiTree p = T, r = NULL;
	LinkStack s;
	InitStack(s);
	while ( p != NULL || !StackEmpty(s))
	{
		if (p) {
			Push(s, p);
			p = p->lchild;
		}
		else
		{
			GetTop(s, p);
			if (p->rchild && p->rchild != r) {
				p = p->rchild;
				Push(s, p);
				p = p->lchild;
			}
			else
			{
				Pop(s, p);
				Visit(p->data);
				r = p;
				p = NULL;
			}
		}
    }
	return 1;
}
```
### 层序遍历
层序遍历需要使用队列queue
```
//层次遍历
#define QElemType BiTree
#define Status int
//---------链队列实现--------------
typedef struct QNode{
    QElemType data;
    struct QNode *next;
} QNode, *QueuePtr；
typedef struct{
    QueuePtr front;
    QueuePtr rear;
} LinkQueue;
Status QueueEmpty(LinkQueue Q){
    if (Q.front == Q.rear)
        return 1;
    else
        return 0;
}
Status InitQueue(LinkQueue &Q){
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    if (!Q.front)
        exit(_OVERFLOW);
    Q.front->next = NULL;
    return 1;
}
Status EnQueue(LinkQueue &Q, QElemType e){
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
    if (!p)
        exit(_OVERFLOW);
    p->data = e;
    p->next = NULL;
    Q.rear->next = p; 
    Q.rear = p;    
    return 1;
}

Status DeQueue(LinkQueue &Q, QElemType &e){
    QueuePtr p;
    if (Q.front == Q.rear)
        return 0;
    p = Q.front->next;   
    e = p->data;           
    Q.front->next = p->next; 
    if (Q.rear == p)  
        Q.rear = Q.front;
    free(p);
    return 1;
}
```

```
//代码实现
Status LevelOrderTraverse(BiTree &T){
	LinkQueue lq;
    InitQueue(lq);
    QElemType q;卜
    EnQueue(lq, T);
    while (QueueEmpty(lq) != 1){ //队列不空，则出队
        DeQueue(lq, q);
        printf("%c ", q->data);
        if(q->lchild)
            EnQueue(lq, q->lchild); //若有左孩子，则入队
        if(q->rchild)
            EnQueue(lq, q->rchild); //若有右孩子，则入队
    }
    return 1; 
}

int main(){
    printf("测试代码\n");
	BiTree T;
	T = (BiTree)malloc(sizeof(BiTNode));
	printf("请给二叉树按照先序方式依次输入结点的值(空结点为#):\n");
	CreateBiTree(T);
	printf("层序方式遍历结果：\n");
	LevelOrderTraverse(T);
	printf("\n");
    return 0;
}
```
##线索二叉树-代码实现算法6.5-6.7
```
#include<bits/stdc++.h>
using namespace std;
#define TElemType char
#define Status int
typedef enum PointerTag
{
    Link,
    Thread
};
//-------------二叉树的二叉线索类型存储表示---------------------
typedef struct BiThrNode
{
	TElemType data;	                    // 结点数据域
	struct BiThrNode *lchild, *rchild;	// 左右孩子指针
	int LTag, RTag;
}BiThrNode, *BiThrTree;
 
//---------------全局变量pre----------------------------------
BiThrNode *pre = new BiThrNode;
 
//---------------建立二叉链表---------------------------------
Status CreateBiTree(BiThrTree &T){ 
    TElemType ch;
    scanf("%c", &ch);
    if (ch == ' ') 
        T = NULL;
    else
    {
        T = (BiThrTree)malloc(sizeof(BiThrNode));
        if (!T)
            exit(_OVERFLOW);
        T->data = ch;             
        CreateBiTree(T->lchild); 
        CreateBiTree(T->rchild);
    }
    return 1;
}
//--------------------算法6.5------------------------------------
Status InOrderTraverse_Thr(BiThrTree T,Status(*Visit)(TElemType e))
{
	//中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出
	BiThrTree p;
	p = T->lchild;                      // p指向根结点
	while (p != T)		                // 空树或遍历结束时，p==T
	{
		while (p->LTag == Link)         // 沿左孩子向下
			p = p->lchild;	            // 访问其左子树为空的结点
		if(!Visit(p->data))
            return 0;
        while (p->RTag == Thread && p->rchild != T)
		{
			p = p->rchild;	            // 沿右线索访问后继结点
            Visit(p->data);
        }
		p = p->rchild;
	}
    return 1;
}		
//---------------------算法6.6-------------------------------------
// 带头结点的中序线索化
Status InOrderThreading(BiThrTree &Thrt, BiThrTree T)
{
	//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点
    if(!(Thrt=(BiThrTree)malloc(sizeof(BiThrNode))))// 建头结点
        exit(_OVERFLOW);
	Thrt->LTag = Link;                  // 头结点有左孩子，若树非空，则其左孩子为树根
	Thrt->RTag = Thread;                // 头结点的右孩子指针为右线索
	Thrt->rchild = Thrt;                // 初始化时右指针指向自己
	if (!T)  
		Thrt->lchild = Thrt;            // 若树为空，则左指针也指向自己
	else
	{
		Thrt->lchild = T;  pre = Thrt; 	// 头结点的左孩子指向根，pre初值指向头结点
		InThreading(T);                 // 对以T为根的二叉树进行中序线索化
		pre->rchild = Thrt;             // pre为最右结点，pre的右线索指向头结点
		pre->RTag = Thread;
		Thrt->rchild = pre;             // 头结点的右线索指向pre
	}
    return 1;
} 						
 
											
//---------------------算法6.7-------------------------------------
// 以结点P为根的子树中序线索化
void InThreading(BiThrTree p)
{
	// pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索
	if (p)
	{
		InThreading(p->lchild);   // 左子树递归线索化
		if (!p->lchild)
		{                   	     // p的左孩子为空
			p->LTag = Thread;        // 给p加上左线索
			p->lchild = pre;         // p的左孩子指针指向pre（前驱）
		}
		else
			p->LTag = Link;
		if (!pre->rchild)
		{					        // pre的右孩子为空
			pre->RTag = Thread;     // 给pre加上右线索
			pre->rchild = p;        // pre的右孩子指针指向p（后继）
		}
		else
			pre->RTag = Link;
		pre = p;                 // 保持pre指向p的前驱
		InThreading(p->rchild);  // 右子树递归线索化
	}
}
Status visit(TElemType e){
    cout << e;
    return 1;
}
int main()
{
	pre->RTag = 1;
	pre->rchild = NULL;
	BiThrTree tree, Thrt;
	
	cout << "请输入建立二叉链表的序列：\n";
	CreateBiTree(tree);                 //建树
	InOrderThreading(Thrt, tree);       //线索化
	cout << "中序遍历线索二叉树的结果为：\n";
	InOrderTraverse_Thr(Thrt,visit);    //中序遍历线索二叉树
	cout << endl;
 
	system("pause");
 
	return 0;
}
```
## 哈夫曼树&哈夫曼编码-代码实现算法6.12-6.13

```
#include<bits/stdc++.h>
using namespace std;
//------哈夫曼树和哈夫曼编码的存储表示--------
typedef struct{
    unsigned int weight;
    unsigned int parent, lcd, rcd;
} HTNode, *HuffmanTree;
typedef char **HuffmanCode;

//-----哈夫曼树-----------------------------
int min1(HuffmanTree t, int i)
{ /* 函数void select()调用 */
	int j, flag;
	unsigned int k = 1e9; /* 取k为不小于可能的值 */
	for (j = 1; j <= i; j++)
		if (t[j].weight < k&&t[j].parent == 0)
			k = t[j].weight, flag = j;
	t[flag].parent = 1;
	return flag;
}
 
void Select(HuffmanTree t, int i, int &s1, int &s2)
{ /* s1为最小的两个值中序号小的那个 */
	int j;
	s1 = min1(t, i);
	s2 = min1(t, i);
	if (s1 > s2)
	{
		j = s1;
		s1 = s2;
		s2 = j;
	}
}
//算法6.12
void HuffmanCoding(HuffmanTree &HT,HuffmanCode &HC,int *w,int n){
    //w存放n个字符的权值（均>0）构造哈夫曼树HT，并求出n个字符的哈夫曼树编码HC
    if(n<=1)
        return;
    int m = 2 * n - 1;
    int i, s1, s2;
    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));
    HuffmanTree p;
    for (p = HT + 1, i = 1; i <= n; ++i, ++p, ++w){
        p->weight = *w;
        cout<<*w<<" ";
        p->parent = 0;
        p->lcd = 0;
        p->rcd = 0;
    }
    cout<<endl;
    for (i = n + 1; i <= m; ++i, ++p){
        p->weight = 0;
        p->parent = 0;
        p->lcd = 0;
        p->rcd = 0;
    }
    cout<<"Try to print the initial huffman Tree table."<<endl;
 
	for(int i = 1;i<=m;++i){
		cout<<HT[i].weight<<" "<<HT[i].parent<<" "<<HT[i].lcd<<" "<<HT[i].rcd<<endl;
	}
	
    for (i = n + 1; i <= m;i++){
        Select(HT, i - 1, s1, s2);
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lcd = s1;
        HT[i].rcd = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
    
    	cout<<"Try to print the created huffman Tree table."<<endl;
	for(int i = 1;i<=m;++i){
		cout<<HT[i].weight<<" "<<HT[i].parent<<" "<<HT[i].lcd<<" "<<HT[i].rcd<<endl;
	}
    
    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *));
    char* cd = (char *)malloc(n * sizeof(char));
    cd[n - 1] = '\0';
    int start, c, f;
    for (i = 1; i <= n;i++){
        start = n - 1;
        for (c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent){
            if (HT[f].lcd == c)
                cd[--start] = '0';
            else
                cd[--start] = '1';
        }
        HC[i] = (char *)malloc((n - start) * sizeof(char));
        strcpy(HC[i], &cd[start]);
        free(cd);
    }
}
//算法6.13
void HuffmanCoding2(HuffmanTree &HT,HuffmanCode &HC,int *w,int n){
    //w存放n个字符的权值（均>0）构造哈夫曼树HT，并求出n个字符的哈夫曼树编码HC
    if(n<=1)
        return;
    int m = 2 * n - 1;
    int i, s1, s2;
    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));
    HuffmanTree p;
    for (p = HT + 1, i = 1; i <= n; i++, p++, w++){
        p->weight = *w;
        p->parent = 0;
        p->lcd = 0;
        p->rcd = 0;
    }
    for (i = n + 1; i <= m; i++, p++){
        p->weight = 0;
        p->parent = 0;
        p->lcd = 0;
        p->rcd = 0;
    }
    for (i = n + 1; i <= m;i++){
        Select(HT, i - 1, s1, s2);
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lcd = s1;
        HT[i].rcd = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *));
    int q = m;
    char *cd = (char *)malloc(n * sizeof(char));
    int cdlen=0;
	for(i=1;i<=m;++i)
		HT[i].weight=0;
	while(q){	
        if(HT[q].weight==0){
            HT[q].weight = 1;
            if (HT[q].lcd != 0){
                q = HT[q].lcd;
                cd[cdlen++] = '0';
            }
			else if(HT[q].rcd==0){
                HC[q] = (char *)malloc((cdlen + 1) * sizeof(char));
                cd[cdlen] = '\0';
                strcpy(HC[q], cd);
            }
		}
		else if(HT[q].weight==1){
            HT[q].weight = 2;
            if(HT[q].rcd!=0){	
                q=HT[q].rcd;
				cd[cdlen++]='1';
			}
		}
		else{	
            HT[q].weight=0;
			q=HT[q].parent;
			--cdlen;
		}
	}
}

int main()
{
    HuffmanTree HT;
    HuffmanCode HC;
    int n;
    int data[1000];

    while(scanf("%d", &n) != EOF){
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &data[i]);
        }
        cout<<endl;
        HuffmanCoding2(HT, HC, data+1, n);
        for (int i = 1; i <= n; ++i) {
            printf("%s\n", HC[i]);
        }
        delete(HC);
        delete(HT);
    }

    return 0;
}


```
# 图
## 邻接矩阵&图&DFS&BFS-代码实现算法7.1-7.6
```
#include <bits/stdc++.h>
using namespace std;
#define OVERFLOW -2 //内存溢出错误常量
#define OK 1        //表示操作正确的常量
#define ERROR 0     //表示操作错误的常量
#define TRUE 1      //表示逻辑真的常量
#define FALSE 0     //表示逻辑假的常量

typedef int Status; //指定状态码的类型是int
#define INFINITY 65535
#define MAX_VERTEX_NUM 20

typedef enum{
  //（有向图=0，有向网=1，无向图=2，无向网=3）
    DG,
    DN,
    UDG,
    UDN
} GraphKind;
typedef int VRType;
typedef int VertexType;
typedef struct ArcCell{
    VRType adj;
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

typedef struct{
    VertexType vexs[MAX_VERTEX_NUM];
    AdjMatrix arcs;
    int vexnum, arcnum;
    GraphKind kind;
} MGraph;
//----------队列---------------------------------
#define MAXQSIZE 100 //队列的最大长度
typedef int Status;
typedef int QElemType;

typedef struct{ //循环队列的C语言描述
    QElemType *base; //初始化动态分配存储空间
    int front;       //头指针，若队列不空，指向队头元素
    int rear;        //尾指针，若队列不空，指向队尾元素的下一个位置
} SqQueue;

//----------------------循环队列的主要操作------------------------
Status InitQueue_Sq(SqQueue &Q){
    if (!(Q.base = (QElemType *)malloc(MAXQSIZE * sizeof(QElemType)))){
        printf("内存分配失败，程序即将退出！\n");
        exit(OVERFLOW);
    }
    Q.front = Q.rear = 0;
    return OK;
}
Status DestoryQueue_Sq(SqQueue &Q){
    if (Q.base){
        free(Q.base);
    }
    Q.base = NULL;
    Q.front = Q.rear = 0;
    return OK;
}
Status QueueEmpty_Sq(SqQueue Q){
    if (Q.rear == Q.front){
        return TRUE;
    }
    else{
        return FALSE;
    }
}
Status EnQueue_Sq(SqQueue &Q, QElemType e){
    if ((Q.rear + 1) % MAXQSIZE == Q.front){ 
        return ERROR;
    } 
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXQSIZE;
    return OK;
} 
Status DeQueue_Sq(SqQueue &Q, QElemType &e){
    if (QueueEmpty_Sq(Q)){
        return ERROR;
    }
    e = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAXQSIZE;
    return OK;
}
int LocateVex(MGraph G, VertexType u) {
    int i;
    
    for(i = 0; i < G.vexnum; i++) {
        if(G.vexs[i] == u) {
            return i;
        }
    }
    
    return -1;
}

//算法7.2
Status CreateUDN(MGraph &G){
    VertexType v1, v2;
    int w, i, j;
    printf("请依次输入无向网G的顶点数和弧数\n");
    scanf("%d%d", &G.vexnum, &G.arcnum);
    printf("请依次输入无向网G的顶点名称，用空格隔开\n");
    for (int i = 0; i < G.vexnum; ++i){
        scanf("%d", &G.vexs[i]);
    }
    for (int i = 0; i < G.vexnum; ++i)
        for (int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j].adj = INFINITY;
    printf("请依次输入无向网G每条弧依附的两顶点名称及权值，输完一组按回车\n");
    for (int k = 0; k < G.arcnum; ++k)
    {
        scanf("%d", &v1);
        scanf("%d", &v2);
        scanf("%d", &w);
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = w;
        G.arcs[j][i] = G.arcs[i][j];
    } 
    return OK;
} // CreateUDN
Status CreateUDG(MGraph &G){
    VertexType v1, v2;
    int i, j;
    printf("请依次输入无向图G的顶点数和弧数\n");
    scanf("%d%d", &G.vexnum, &G.arcnum);
    printf("请依次输入无向图G的顶点名称，用空格隔开\n");
    for (int i = 0; i < G.vexnum; ++i){
        scanf("%d", &G.vexs[i]);
    }
    for (int i = 0; i < G.vexnum; ++i)
        for (int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j].adj = 0;
    printf("请依次输入无向图G每条弧依附的两顶点名称，输完一组按回车\n");
    for (int k = 0; k < G.arcnum; ++k){
        scanf("%d", &v1);
        scanf("%d", &v2);
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1;
        G.arcs[j][i] = G.arcs[i][j];
    }
    return OK;
}

Status CreateDN(MGraph &G)
{
    VertexType v1, v2;
    int w, i, j;
    printf("请依次输入有向网G的顶点数和弧数\n");
    scanf("%d%d", &G.vexnum, &G.arcnum);
    printf("请依次输入有向网G的顶点名称，用空格隔开\n");
    for (int i = 0; i < G.vexnum; ++i){
        scanf("%d", &G.vexs[i]);
    }
    for (int i = 0; i < G.vexnum; ++i)
        for (int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j].adj = INFINITY;
    printf("请依次输入有向网G每条弧依附的两顶点名称及权值，输完一组按回车\n");
    for (int k = 0; k < G.arcnum; ++k){
        scanf("%d", &v1);
        scanf("%d", &v2);
        scanf("%d", &w);
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = w;
    } 
    return OK;
} // CreateDN

Status CreateDG(MGraph &G){
    VertexType v1, v2;
    int i, j;
    printf("请依次输入有向图G的顶点数和弧数\n");
    scanf("%d%d", &G.vexnum, &G.arcnum);
    printf("请依次输入有向图G的顶点名称，用空格隔开\n");
    for (int i = 0; i < G.vexnum; ++i){
        scanf("%d", &G.vexs[i]);
    }
    for (int i = 0; i < G.vexnum; ++i)
        for (int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j].adj = 0;
    printf("请依次输入有向图G每条弧依附的两顶点名称，输完一组按回车\n");
    for (int k = 0; k < G.arcnum; ++k){
        scanf("%d", &v1);
        scanf("%d", &v2);
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        G.arcs[i][j].adj = 1;
    }
    return OK;
} // CreateDG

//算法7.1
Status CreateGraph(MGraph &G){
    printf("请输入您想构造的图的类型:有向图输入0,有向网输入1,无向图输入2,无向网输入3):");
    scanf("%d", &G.kind);
    switch (G.kind)
    {
    case DG:
        return CreateDG(G); //构造有向图G
    case DN:
        return CreateDN(G); //构造有向网G
    case UDG:
        return CreateUDG(G); //构造无向图G
    case UDN:
        return CreateUDN(G); //构造无向网G
    default:
        return ERROR;
    } 
} //CreateGraph

Status DestroyGraph(MGraph &G){
    if (G.kind % 2){
        for (int i = 0; i < G.vexnum; i++){
            for (int j = 0; j < G.vexnum; j++){
                G.arcs[i][j].adj = INFINITY;
            } 
        }    
    }  
    else{ //若是图
        for (int i = 0; i < G.vexnum; i++){
            for (int j = 0; j < G.vexnum; j++){
                G.arcs[i][j].adj = 0;
            } 
        }     
    }   
    G.vexnum = 0;
    G.arcnum = 0;
} //DestroyGraph
Status PrintAdjMatrix(MGraph G){
    printf("      ");
    for (int i = 0; i < G.vexnum; i++){
        printf(" %3d ", G.vexs[i]);
    }
    printf("\n");
    printf("     +");
    for (int i = 0; i < G.vexnum; i++){
        printf("-----");
    } 
    printf("\n");
    for (int i = 0; i < G.vexnum; i++){
        printf(" %3d |", G.vexs[i]);
        for (int j = 0; j < G.vexnum; j++){
            if (G.arcs[i][j].adj == INFINITY){
                printf("  ∞ ");
            } 
            else{
                printf(" %3d ", G.arcs[i][j].adj);
            }
        }
        printf("\n     |\n");
    }
} //PrintAdjMatrix
VertexType &GetVex(MGraph G, int v){
    if (v >= G.vexnum || v < 0){
        exit(ERROR);
    }
    return G.vexs[v];
} //GetVex
Status PutVex(MGraph &G, VertexType v, VertexType value){
    int k = LocateVex(G, v);
    if (k < 0){
        return ERROR;
    }
    G.vexs[k] = value;
    return OK;
} //PutVex

int FirstAdjVex(MGraph G, VertexType v) {
    int kv,j;
    VRType adj;
    kv = LocateVex(G, v);
    if(kv == -1)
        return -1;  
    if(G.kind == DG || G.kind == UDG) {
        adj = 0;            // 图
    } else if(G.kind == DN || G.kind == UDN) {
        adj = INFINITY;     // 网
    } else {
        return -1;
    }
    for(j = 0; j < G.vexnum; j++) {
        if(G.arcs[kv][j].adj != adj) {
            return j;
        }
    }
    return -1;
}
int NextAdjVex(MGraph G, VertexType v, VertexType w) {
    int kv, kw, j;
    VRType adj;
    kv = LocateVex(G, v);
    if(kv == -1) 
        return -1; 
    kw = LocateVex(G, w);
    if(kw == -1) {
        return -1;  
    }
    if(G.kind == DG || G.kind == UDG) {
        adj = 0;        // 图
    } else if(G.kind == DN || G.kind == UDN) {
        adj = INFINITY; // 网
    } else {
        return -1;
    }
    for(j = kw + 1; j < G.vexnum; j++) {
        if(G.arcs[kv][j].adj != adj) {
            return j;
        }
    }
    return -1;
}
Status InsertVex(MGraph &G, VertexType v){
    int j = 0;
    if (G.kind % 2){
        j = INFINITY;
    }
    G.vexs[G.vexnum] = v;
    for (int i = 0; i <= G.vexnum; i++){
        G.arcs[G.vexnum][i].adj = G.arcs[i][G.vexnum].adj = j;
    }
    G.vexnum++;
    return OK;
} //InsertVex
Status DeleteVex(MGraph &G, VertexType v){
    VRType m = 0;
    if (G.kind % 2){
        m = INFINITY;
    } 
    int k = LocateVex(G, v);
    if (k < 0){ 
        return ERROR;
    } 
    for (int j = 0; j < G.vexnum; j++){
        if (G.arcs[j][k].adj != m){
            G.arcs[j][k].adj = m;
            G.arcnum--;
        }
        if (G.arcs[k][j].adj != m) {
            G.arcs[k][j].adj = m;
            G.arcnum--;
        } 
    }   
    for (int j = k + 1; j < G.vexnum; j++){
        G.vexs[j - 1] = G.vexs[j];
    } 
    for (int i = 0; i < G.vexnum; i++){
        for (int j = k + 1; j < G.vexnum; j++){
            G.arcs[i][j - 1] = G.arcs[i][j];
        } 
    }     
    for (int i = 0; i < G.vexnum; i++){
        for (int j = k + 1; j < G.vexnum; j++){
            G.arcs[j - 1][i] = G.arcs[j][i];
        } 
    }
    G.vexnum--;
    return OK;
} //DeleteVex
Status InsertArc(MGraph &G, VertexType v, VertexType w){
    int v1 = LocateVex(G, v);
    int w1 = LocateVex(G, w);
    if (v1 < 0 || w1 < 0){
        return ERROR;
    }
    G.arcnum++;
    if (G.kind % 2){
        printf("请输入此弧或边的权值: ");
        scanf("%d", &G.arcs[v1][w1].adj);
    }
    else
        G.arcs[v1][w1].adj = 1;
    if (G.kind > 1)
        G.arcs[w1][v1].adj = G.arcs[v1][w1].adj;
    return OK;
} //InsertArc

Status DeleteArc(MGraph &G, VertexType v, VertexType w){
    int j = 0;
    if (G.kind % 2){
        j = INFINITY;
    }
    int v1 = LocateVex(G, v);
    int w1 = LocateVex(G, w);
    if (v1 < 0 || w1 < 0)
        return ERROR;
    G.arcs[v1][w1].adj = j;
    if (G.kind >= 2)
        G.arcs[w1][v1].adj = j;
    G.arcnum--;
    return OK;
} //DeleteArc
//-----------------------深度优先遍历DFS-----------------------------
int visited[MAX_VERTEX_NUM];
Status (*VisitFunc)(int v);
Status Print(int v){
    printf(" %3d ", v);
    return OK;
}
//算法7.5
void DFS(MGraph G, int v){
    visited[v] = TRUE;
    VisitFunc(G.vexs[v]);
    for (int w = FirstAdjVex(G, G.vexs[v]); w >= 0;w = NextAdjVex(G, G.vexs[v], G.vexs[w])){
        if (!visited[w]){
            DFS(G, w);
        } 
    } 
} //DFS
//算法7.4
void DFSTraverse(MGraph G, Status (*Visit)(int v)){
    VisitFunc = Visit;
    for (int v = 0; v < G.vexnum; ++v)
        visited[v] = FALSE;
    for (int v = 0; v < G.vexnum; ++v){
        if (!visited[v])
            DFS(G, v);
    }
} //DFSTraverse

//----------------广度优先遍历 (需要使用队列)BFS------------
//算法7.6
void BFSTraverse(MGraph G, Status (*Visit)(int v)){
    int u;
    SqQueue Q;
    for (int v = 0; v < G.vexnum; ++v){
        visited[v] = FALSE;
    }
    InitQueue_Sq(Q);
    for (int v = 0; v < G.vexnum; ++v){
        if (visited[v])
            continue;
        visited[v] = TRUE;
        Visit(G.vexs[v]);
        EnQueue_Sq(Q, v);
        while (!QueueEmpty_Sq(Q)){
            DeQueue_Sq(Q, u);
            for (int w = FirstAdjVex(G, G.vexs[u]); w >= 0;
                    w = NextAdjVex(G, G.vexs[u], G.vexs[w])){
                if (!visited[w]){
                    visited[w] = TRUE;
                    Visit(G.vexs[w]);
                    EnQueue_Sq(Q, w);
                } 
            }    
        }        
    }
} //BFSTraverse

//----------------------主函数----------------------
int main(){

    printf("\n-------------图的邻接矩阵表示法基本操作测试程序--------------\n\n");
    MGraph G;
    VertexType v1, v2;
    int n;
    printf("->测试图的创建：\n");
    CreateGraph(G);
    // printf("\n->创建成功后图的邻接矩阵:\n\n");
    // PrintAdjMatrix(G);
    //测试图的遍历（深度、广度）
    printf("\n->测试图的遍历:\n");
    printf("->深度优先遍历结果：");
    DFSTraverse(G, Print);

    printf("\n->广度优先遍历结果：");
    BFSTraverse(G, Print);
    printf("\n");
    return 0;
}

```
## 邻接表&图&DFS&BFS-代码实现算法7.1-7.6
```
#include<bits/stdc++.h>
using namespace std;

//边表节点结构，一个adjvex用来存储邻接点的位置，一个next指针用来指向下一个节点
typedef struct EdgeNode
{
    int adjvex;
    struct EdgeNode * next;
} EdgeNode;
 
//顶点表节点结构，一个data用来存储数据，一个firstedge是用来指向边表的第一个节点
typedef struct
{
    string data;
    EdgeNode * firstedge;
} AdjList;

//里面的adjList[15]表示我给顶点表开了15的单位大小，然后numVertex,numEdge是一个图的顶点数和边数
typedef struct
{
    AdjList adjList[15];
    int numVertex,numEdge;
} GraphAdjList;
//这个函数是这样的，它会遍历图的顶点，然后返回一个位置（其实也就是它所在的下标）
int local(GraphAdjList G,string val)
{
    for(int i=0; i<G.numVertex; i++)
    {
        if(G.adjList[i].data==val)
            return i;
    }
    return -1;
}
//比如v2的位置是在2 这个可以看上面的顶点表图 
void CreateGraph(GraphAdjList & G)
{
    int i,j,k;
    string v1,v2;
    EdgeNode * e,* p,*q;
    cout<<"请输入顶点数和边数，并以空格隔开:"<<endl;
    cin>>G.numVertex>>G.numEdge;
    cout<<"请输入顶点的信息："<<endl;
    for(i=0; i<(G.numVertex); i++)
    {
        //cout<<"第"<<i+1<<"个顶点："<<endl;
        cin>>G.adjList[i].data;
        G.adjList[i].firstedge=NULL;
    }
    for(k=0; k<(G.numEdge); k++)
    {
        //cout<<"请输入边（Vi,Vj）上的顶点信息:"<<endl;
        cin>>v1>>v2;
        i=local(G,v1);
        j=local(G,v2);
 
        if(G.adjList[i].firstedge==NULL)
        {
            e= new EdgeNode;
            e->adjvex=j;
            e->next=NULL;
            G.adjList[i].firstedge=e;
        }
        else
        {
            p=G.adjList[i].firstedge;
            while(p->next!=NULL)
            {
                p=p->next;
            }
            e = new EdgeNode;
            e->adjvex=j;
            e->next=NULL;
            p->next=e;
        }
        if(G.adjList[j].firstedge==NULL)
        {
            e= new EdgeNode;
            e->adjvex=i;
            e->next=NULL;
            G.adjList[j].firstedge=e;
        }
        else
        {
            p=G.adjList[j].firstedge;
            while(p->next!=NULL)
            {
                p=p->next;
            }
            e = new EdgeNode;
            e->adjvex=i;
            e->next=NULL;
            p->next=e;
        }
    }
}
void Prin(GraphAdjList G)
{
    cout<<"所建立的邻接表如以下所示："<<endl;
    for(int i=0; i<G.numVertex; i++)
    {
        cout<<G.adjList[i].data;             //先输出顶点信息
        EdgeNode * e = G.adjList[i].firstedge;
        while(e)                              //然后就开始遍历输出每个边表所存储的邻接点的下标
        {
            cout<<"-->"<<e->adjvex;
            e=e->next;
        }
        cout<<endl;
    }
}
bool DFSvisited[50];  //用于深搜的标记数组
bool BFSvisited[50];  //用于广搜的标记数组
void DFS(GraphAdjList  G,int i)
{
 
    EdgeNode * p;
    DFSvisited[i]=true;
    cout<<G.adjList[i].data<<"  ";
    p=G.adjList[i].firstedge;
    while(p)
    {
        if(!DFSvisited[p->adjvex])
            DFS(G,p->adjvex);
        p=p->next;
    }
}
void DFSTraverse(GraphAdjList  G)
{
    for(int i=0; i<G.numVertex; i++)
        DFSvisited[i]=false;
    for(int i=0; i<G.numVertex; i++)
    {
        if(!DFSvisited[i])
            DFS(G,i);
    }
}
void BFSTraverse(GraphAdjList  G)
{
    EdgeNode * p;
    queue<int>q;
    for(int i=0; i<G.numVertex; i++)
        BFSvisited[i]=false;
    for(int i=0; i<G.numVertex; i++)
    {
        if(!BFSvisited[i])
        {
            BFSvisited[i]=true;
            cout<<G.adjList[i].data<<"  ";
            q.push(i);
            while(!q.empty())
            {
                int count =q.front();
                q.pop();
                p=G.adjList[count].firstedge;
                while(p)
                {
                    if(!BFSvisited[p->adjvex])
                    {
                        BFSvisited[p->adjvex]=true;
                        cout<<G.adjList[p->adjvex].data<<"  ";
                        q.push(p->adjvex);
                    }
                    p=p->next;
                }
            }
        }
    }
}

int main(){
	GraphAdjList G;
	CreateGraph(G);
	Prin(G);
	cout << "BFS:" << endl;
	BFSTraverse(G);
	cout << endl;
	cout << "DFS:" << endl;
	DFSTraverse(G);
	return 0;
}

```
## 无向图的联通分量和生成树-代码实现算法7.7-7.8
```
#include<bits/stdc++.h>
using namespace std;
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2

#define MAXSIZE 20  //最大顶点数
typedef int Status;
typedef int ElemType;
typedef struct CSNode
{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;

typedef int Boolean;
Boolean Visited[MAXSIZE];  //访问标志数组

#define  INFINITY 65535   //最大值∞
#define MAX_VERTEX_NUM 20  //最大顶点个数

typedef int Status;
typedef int VRType;
typedef char InfoType;
typedef int VertexType;
typedef enum {DG,DN,UDG,UDN}GraphKind;   //{有向图，有向网，无向图，无向网}

typedef struct ArcCell
{
    VRType adj;  //VRType 是顶点关系类型。对无权图，用0或1表示相邻否；对带权图，则为权值类型
    InfoType *info; //该弧相关信息的指针
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct
{
    VertexType vexs[MAX_VERTEX_NUM];  //顶点向量
    AdjMatrix arcs;  //邻接矩阵
    int vexnum,arcnum;  //图的当前顶点数和弧数
    GraphKind kind;  //图的种类标志
}MGraph;

/*******************************声明部分****************************************/
int FirstAdjVex(MGraph G,int v);
//返回v的第一个邻接顶点
int NextAdjVex(MGraph G,int v,int w);
//返回v的（相对于w的）下一个邻接顶点
VertexType Getvex(MGraph G,int v);
//v是G中的某个顶点，返回v的值

/*******************************函数部分****************************************/
Status CreateUDG(MGraph *G)
{
    printf("\n构造无向图\n");
    int i,j,k; //i,j,k用于计数
    VertexType v1,v2;  //弧头，弧尾

    printf("请输入顶点个数：");
    scanf("%d",&(*G).vexnum);
    printf("请输入弧个数：");
    scanf("%d",&(*G).arcnum);
    //假定该图不含其他信息
    int IncInfo = 0;

    for(i = 0;i<(*G).vexnum;i++){  //构造顶点向量
        printf("请输入G.vexs[%d] = ",i);
        scanf("%d",&(*G).vexs[i]);
    } //for

    for(i = 0;i<(*G).vexnum;i++)  //初始化邻接矩阵
        for(j = 0;j<(*G).vexnum;j++){
            (*G).arcs[i][j].adj = 0;  //无向图
            (*G).arcs[i][j].info = NULL;
        }

    for(k = 0;k<(*G).arcnum;k++){  //构造邻接矩阵
        printf("请输入弧头(初始点)：");  //输入一条弧的始点和终点
        scanf("%d",&v1);
        printf("请输入弧尾(终端点)：");
        scanf("%d",&v2);

        i = LocateVex(*G,v1);
        j = LocateVex(*G,v2);

        if(i>=0 && j>=0)
            (*G).arcs[i][j].adj = (*G).arcs[j][i].adj = 1;
            //置<v1,v2>的对称弧<v2,v1>
    }
    G->kind = UDG;
    return OK;
}
//作者：https://blog.csdn.net/eternity_memory?spm=3001.5343
Status CreateUDG_auto(MGraph *G)
{
    printf("\n构造无向图\n");
    int i,j,k; //i,j,k用于计数
    VertexType v1,v2;  //弧头，弧尾

   /* printf("请输入顶点个数：");
    scanf("%d",&(*G).vexnum);
    printf("请输入弧个数：");
    scanf("%d",&(*G).arcnum);*/
    G->vexnum = 5;
    G->arcnum = 6;
    //假定该图不含其他信息
    int IncInfo = 0;

    /*for(i = 0;i<(*G).vexnum;i++){  //构造顶点向量
        printf("请输入G.vexs[%d] = ",i);
        scanf("%d",&(*G).vexs[i]);
    } //for*/

    for(i = 0;i<(*G).vexnum;i++){  //构造顶点向量
        //printf("请输入G.vexs[%d] = ",i);
       // scanf("%d",&(*G).vexs[i]);
        G->vexs[i] = i+1;
    } //for

    for(i = 0;i<(*G).vexnum;i++)  //初始化邻接矩阵
        for(j = 0;j<(*G).vexnum;j++){
            (*G).arcs[i][j].adj = 0;  //无向图
            (*G).arcs[i][j].info = NULL;
        }

    int v1_list[6] = {1,1,2,3,3,2};
    int v2_list[6] = {2,4,3,4,5,5};
    for(k = 0;k<(*G).arcnum;k++){  //构造邻接矩阵
      /*  printf("请输入弧头(初始点)：");  //输入一条弧的始点和终点
        scanf("%d",&v1);
        printf("请输入弧尾(终端点)：");
        scanf("%d",&v2);*/
        v1 = v1_list[k];
        v2 = v2_list[k];

        i = LocateVex(*G,v1);
        j = LocateVex(*G,v2);

        if(i>=0 && j>=0)
            (*G).arcs[i][j].adj = (*G).arcs[j][i].adj = 1;
            //置<v1,v2>的对称弧<v2,v1>
    }
    G->kind = UDG;
    return OK;
}

int LocateVex(MGraph G,VertexType v)
{
    int ct;
    for(ct = 0;ct < G.vexnum;ct++)
        if(G.vexs[ct] == v)
            return ct;
    return -1;
}

Status PrintfArcs(MGraph G)
{
    int n = G.vexnum;
    int i,j;  //i,j用于计数
    for(i = 0;i < n;i++){
        for(j = 0;j<n;j++){
            printf("%d ",G.arcs[i][j]);
        }
        printf("\n");
    }
    return OK;
}

VertexType Getvex(MGraph G,int v)
{
    return G.vexs[v];
}

int FirstAdjVex(MGraph G,int v)
{

    int k,j ,t;
    k = LocateVex(G,v);
    if(k)
    {
        t = 0;
        for(j = 0;j <G.vexnum;j++)
            if(G.arcs[k][j].adj != t)
                return j;
    }
    return -1;
}

int NextAdjVex(MGraph G,int v,int w)
{
    int j,t,k1,k2;
    t = 0;
    for(j = w+1;j<G.vexnum;j++)
        if(G.arcs[v][j].adj != t)
            return j;
    return -1;
}

void DFSTree(MGraph G,int v,CSTree *T)
{
    int first,w;
    CSTree p,q;
    Visited[v] = TRUE;
    first = TRUE;

    for(w = FirstAdjVex(G,G.vexs[v]);w >= 0;w = NextAdjVex(G,G.vexs[v],G.vexs[w])){
        if(!Visited[w]){
            p = (CSTree)malloc(sizeof(CSNode));  //分配孩子结点
            p->data = Getvex(G,w);   //给该结点赋值
            p->firstchild = NULL;
            p->nextsibling = NULL;
            if(first){      //w是v的第一个未被访问的邻接顶点
                (*T)->firstchild = p;  //是根的左孩子结点
                first = FALSE;
            }//if
            else  //w是v的其他未被访问的邻接顶点
                q->nextsibling = p;  //是上一邻接顶点的右兄弟结点
            q = p;
            DFSTree(G,w,&q);  //从第w个顶点出发深度优先遍历图G，建立子生成树q
        }//if
    }//for
}

void DFSForest(MGraph G,CSTree *T)
{
    int v;
    CSTree p,q;

    *T = p = q = NULL;
    for(v = 0;v<G.vexnum;v++)
        Visited[v] = FALSE;

    for(v = 0;v<G.vexnum;v++)
    if(!Visited[v]){    //第v顶点为新的生成树的根的根结点
        p = (CSTree)malloc(sizeof(CSNode));  //分配根结点
        p->data = Getvex(G,v);   //给该结点赋值
        p->firstchild = NULL;
        p->nextsibling = NULL;
        if(!(*T))
            *T = p;  //是第一棵生成树的根（T的根）
        else
            q->nextsibling = p;  //是其他生成树的根（前一棵树的根的“兄弟”）
        q = p;  //q指示当前生成树的根
        DFSTree(G,v,&p);  //建立以p为根的生成树
    }//if
}

Status Visit(int e)
{
    printf("%d,",e);
    return OK;
}

Status PreOrderTraverse(CSTree T,Status(*Visit)(int e))  //递归
{
    if(T){
        if(Visit(T->data))
            if(PreOrderTraverse(T->firstchild,Visit))
                if(PreOrderTraverse(T->nextsibling,Visit))
                    return OK;
        return ERROR;
    }
    else
        return OK;
}

void VisitFunc(MGraph G,int v)
{
    printf("%d ",G.vexs[v]);  //打印该顶点
}

void DFS(MGraph G,int v)
{
    int w;
    Visited[v] = TRUE;
    VisitFunc(G,v);  //访问第v个顶点
    for(w = 0;w<G.vexnum;w++)
        if(G.arcs[v][w].adj == 1 && !Visited[w])
            DFS(G,w);  //对v的尚未访问的邻接顶点w递归调用DFS
}

void DFSTraverse(MGraph G)
{
    int v;
    for(v = 0;v<G.vexnum;++v)  //访问标志数组初始化
        Visited[v] = FALSE;
    for(v = 0;v<G.vexnum;++v)
        if(!Visited[v])
            DFS(G,v);  //对尚未访问的顶点调用DFS
}
//作者：https://blog.csdn.net/eternity_memory?spm=3001.5343
/*******************************主函数部分**************************************/
int main()
{
    MGraph G;
    printf("\n创建并输出无向图（数组表示法）：\n");
    CreateUDG_auto(&G);
    PrintfArcs(G);
    printf("\n创建完毕,DFS遍历输出图:\n");
    DFSTraverse(G);

    CSTree T;
    printf("\n\n创建并输出无向图的生成树：\n");
    DFSForest(G,&T);
    printf("\n创建完毕,输出树\n");
    PreOrderTraverse(T,Visit);
    return 0;
}

```
## 最小生成树：普里姆( Prim )算法/克鲁斯卡尔( Kruskal )算法-代码实现算法7.7-7.8
```
#include <bits/stdc++.h>
using namespace std;
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INFINITY 65535    //最大值∞
#define MAX_VERTEX_NUM 20 //最大顶点个数

typedef int Status;
typedef int VRType;
typedef char InfoType;
typedef int VertexType;
typedef enum
{
    DG,
    DN,
    UDG,
    UDN
} GraphKind; //{有向图，有向网，无向图，无向网}

typedef struct ArcCell
{
    VRType adj;     //VRType 是顶点关系类型。对无权图，用0或1表示相邻否；对带权图，则为权值类型
    InfoType *info; //该弧相关信息的指针
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct
{
    VertexType vexs[MAX_VERTEX_NUM]; //顶点向量
    AdjMatrix arcs;                  //邻接矩阵
    int vexnum, arcnum;              //图的当前顶点数和弧数
    GraphKind kind;                  //图的种类标志
} MGraph;

typedef struct
{
    VertexType adjvex;
    VRType lowcost;
} CLOSEDGE;

/*******************************声明部分****************************************/
Status CreateUDN(MGraph *G);
//构造无向网
int LocateVex(MGraph G, VertexType v);
//确定v在G中的位置
int minimum(CLOSEDGE closedge[], int n);
//返回最小连接的顶点序号
void MiniSpanTree_PRIM(MGraph G, VertexType u);
//用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T的各条边
//记录从顶点集U到V-U的代价最小的边的辅助数组定义
/*******************************函数部分****************************************/
Status CreateUDN(MGraph *G)
{
    printf("\n构造无向网\n");
    int i, j, k;       //i,j,k用于计数
    int w;             //权重
    VertexType v1, v2; //弧头，弧尾

    printf("请输入顶点个数：");
    scanf("%d", &(*G).vexnum);
    printf("请输入弧个数：");
    scanf("%d", &(*G).arcnum);
    //假定该图不含其他信息
    int IncInfo = 0;

    for (i = 0; i < (*G).vexnum; i++)
    { //构造顶点向量
        printf("请输入G.vexs[%d] = ", i);
        scanf("%d", &(*G).vexs[i]);
    } //for

    for (i = 0; i < (*G).vexnum; i++) //初始化邻接矩阵
        for (j = 0; j < (*G).vexnum; j++)
        {
            (*G).arcs[i][j].adj = INFINITY; //无向网
            (*G).arcs[i][j].info = NULL;
        }

    for (k = 0; k < (*G).arcnum; k++)
    {                                   //构造邻接矩阵
        printf("请输入弧头(初始点)："); //输入一条弧的始点和终点
        scanf("%d", &v1);
        printf("请输入弧尾(终端点)：");
        scanf("%d", &v2);
        printf("请输入权重：");
        scanf("%d", &w);

        i = LocateVex(*G, v1);
        j = LocateVex(*G, v2);

        if (i >= 0 && j >= 0)
            (*G).arcs[i][j].adj = (*G).arcs[j][i].adj = w; //置<v1,v2>的对称弧<v2,v1>

        //不再输入该弧含有的相关信息
    }
    (*G).kind = UDN;
    return OK;
}

int LocateVex(MGraph G, VertexType v)
{
    int ct;
    for (ct = 0; ct < G.vexnum; ct++)
        if (G.vexs[ct] == v)
            return ct;
    return -1;
}

int minimum(CLOSEDGE closedge[], int n)
{
    int i = 0, j, min, k;
    while (!closedge[i].lowcost)
        i++;
    min = closedge[i].lowcost;
    k = i;
    for (j = 1; j < n; j++)
        if (closedge[j].lowcost)
            if (min > closedge[j].lowcost)
            {
                min = closedge[j].lowcost;
                k = j;
            } //if
    return k;
}

void MiniSpanTree_PRIM(MGraph G, VertexType u)
{
    CLOSEDGE closedge[G.vexnum + 1];
    int k, j, i;

    k = LocateVex(G, u);
    for (j = 0; j < G.vexnum; ++j)
        if (j != k)
        { //辅助数组初始化
            closedge[j].adjvex = u;
            closedge[j].lowcost = G.arcs[k][j].adj;
        } //if

    closedge[k].lowcost = 0; //初始，U = {u}
    for (i = 1; i < G.vexnum; ++i)
    { //选择其余G.vexnum-1个顶点

        k = minimum(closedge, G.vexnum);                    //求出T的下一个结点：第k个顶点
        printf("(%d,%d)\n", closedge[k].adjvex, G.vexs[k]); //输出生成树的边

        closedge[k].lowcost = 0; //第k顶点并入U集

        for (j = 0; j < G.vexnum; ++j)
        {
            if (G.arcs[k][j].adj < closedge[j].lowcost)
            { //新顶点并入U集后重新选择最小边
                closedge[j].adjvex = G.vexs[k];
                closedge[j].lowcost = G.arcs[k][j].adj;
            } //if
        }     //for
    }         //for
}

/*******************************主函数部分**************************************/

int main()
{
    MGraph G;
    printf("P174 图7.16（a）\n");
    CreateUDN(&G);
    printf("\n输出生成树上的5条边为：\n");
    MiniSpanTree_PRIM(G, 1);
    return 0;
}
```
```
#include<bits/stdc++.h>
using namespace std;
//hdu 1233 kruskal+并查集
const int NUM = 100;
int s[NUM]; //并查集
struct Edge{
    int u, v, w;
} edge[NUM * NUM];  //定义边
bool cmp(Edge a,Edge b){
    return a.w < b.w;
}
int find(int u){
    return s[u] == u ? u : find(s[u]);
}

int n, m;
int kruskal(){
    int ans = 0;
    for (int i = 1; i <= n; i++)
        s[i] = i;
    sort(edge + 1, edge + 1 + m, cmp);
    for (int i = 1; i <= n;i++){
        int b = find(edge[i].u);
        int c = find(edge[i].v);
        if(b==c)
            continue;
        s[c] = b;
        ans += edge[i].w;
    }
    return ans;
}

int main(){
    while(cin>>n){
        m = n * (n - 1) / 2;
        for (int i = 1; i <= m;i++){
            cin >> edge[i].u >> edge[i].v >> edge[i].w;
        }
        cout << kruskal() << endl;
    }
    return 0;
}


```
## 关节点&重连通分量-代码实现算法7.10-7.11
```
#include<malloc.h> /* malloc()等 */
#include<stdio.h> /* EOF(=^Z或F6),NULL */
#include<process.h> /* exit() */
#include<limits.h> //常量INT_MAX和INT_MIN分别表示最大、最小整数##
#include<string.h> 
/* 函数结果状态代码 */
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2 
#define MAX_NAME 2 /* 顶点字符串的最大长度+1 */
typedef int InfoType;
typedef char VertexType[MAX_NAME]; /* 字符串类型 */
typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */
 
 
/* ---------------------------------  图的邻接表存储表示    --------------------------------*/
 
#define MAX_VERTEX_NUM 20
typedef enum { DG, DN, AG, AN }GraphKind; /* {有向图,有向网,无向图,无向网} */
typedef struct ArcNode
{
	int adjvex; /* 该弧所指向的顶点的位置 */
	struct ArcNode *nextarc; /* 指向下一条弧的指针 */
	InfoType *info; /* 网的权值指针） */
}ArcNode; /* 表结点 */
typedef struct
{
	VertexType data; /* 顶点信息 */
	ArcNode *firstarc; /* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */
}VNode, AdjList[MAX_VERTEX_NUM]; /* 头结点 */
typedef struct
{
	AdjList vertices;
	int vexnum, arcnum; /* 图的当前顶点数和弧数 */
	int kind; /* 图的种类标志 */
}ALGraph;
 
/* ------------------------------------------------------------*/

/* -----------  需要用的图的邻接表存储的基本操作 ----------------*/
 
int LocateVex(ALGraph G, VertexType u)
{ /* 初始条件: 图G存在,u和G中顶点有相同特征 */
  /* 操作结果: 若G中存在顶点u,则返回该顶点在图中位置;否则返回-1 */
	int i;
	for (i = 0; i < G.vexnum; ++i)
		if (strcmp(u, G.vertices[i].data) == 0)
			return i;
	return -1;
}
 
Status CreateGraph(ALGraph *G)
{ /* 采用邻接表存储结构,构造没有相关信息的图G(用一个函数构造4种图) */
	int i, j, k;
	int w; /* 权值 */
	VertexType va, vb;
	ArcNode *p;
	printf("请输入图的类型(有向图:0,有向网:1,无向图:2,无向网:3): ");
	scanf("%d", &(*G).kind);
	printf("请输入图的顶点数,边数: ");
	scanf("%d,%d", &(*G).vexnum, &(*G).arcnum);
	printf("请输入%d个顶点的值(<%d个字符):\n", (*G).vexnum, MAX_NAME);
	for (i = 0; i < (*G).vexnum; ++i) /* 构造顶点向量 */
	{
		scanf("%s", (*G).vertices[i].data);
		(*G).vertices[i].firstarc = NULL;
	}
	if ((*G).kind == 1 || (*G).kind == 3) /* 网 */
		printf("请顺序输入每条弧(边)的权值、弧尾和弧头(以空格作为间隔):\n");
	else /* 图 */
		printf("请顺序输入每条弧(边)的弧尾和弧头(以空格作为间隔):\n");
	for (k = 0; k < (*G).arcnum; ++k) /* 构造表结点链表 */
	{
		if ((*G).kind == 1 || (*G).kind == 3) /* 网 */
			scanf("%d%s%s", &w, va, vb);
		else /* 图 */
			scanf("%s%s", va, vb);
		i = LocateVex(*G, va); /* 弧尾 */
		j = LocateVex(*G, vb); /* 弧头 */
		p = (ArcNode*)malloc(sizeof(ArcNode));
		p->adjvex = j;
		if ((*G).kind == 1 || (*G).kind == 3) /* 网 */
		{
			p->info = (int *)malloc(sizeof(int));
			*(p->info) = w;
		}
		else
			p->info = NULL; /* 图 */
		p->nextarc = (*G).vertices[i].firstarc; /* 插在表头 */
		(*G).vertices[i].firstarc = p;
		if ((*G).kind >= 2) /* 无向图或网,产生第二个表结点 */
		{
			p = (ArcNode*)malloc(sizeof(ArcNode));
			p->adjvex = i;
			if ((*G).kind == 3) /* 无向网 */
			{
				p->info = (int*)malloc(sizeof(int));
				*(p->info) = w;
			}
			else
				p->info = NULL; /* 无向图 */
			p->nextarc = (*G).vertices[j].firstarc; /* 插在表头 */
			(*G).vertices[j].firstarc = p;
		}
	}
	return OK;
}
 
 
Boolean visited[MAX_VERTEX_NUM]; /* 访问标志数组(全局量) */
void(*VisitFunc)(char* v); /* 函数变量(全局量) */
 
 
 
/* ------------------------------------------------------------*/
 
 
 
/* 实现算法7.10、7.11的程序 */
 
int count; /* 全局量count对访问计数 */
int low[MAX_VERTEX_NUM];
 
void DFSArticul(ALGraph G, int v0){
 /* 从第v0个顶点出发深度优先遍历图G，查找并输出关节点。算法7.11 */
	int min, w;
	ArcNode *p;
	visited[v0] = min = ++count; /* v0是第count个访问的顶点 */
	for (p = G.vertices[v0].firstarc; p; p = p->nextarc) /* 对v0的每个邻接顶点检查 */
	{
		w = p->adjvex; /* w为v0的邻接顶点 */
		if (visited[w] == 0) /* w未曾访问，是v0的孩子 */
		{
			DFSArticul(G, w); /* 返回前求得low[w] */
			if (low[w] < min)
				min = low[w];
			if (low[w] >= visited[v0])
				printf("%d %s\n", v0, G.vertices[v0].data); /* 关节点 */
		}
		else if (visited[w] < min)
			min = visited[w]; /* w已访问，w是v0在生成树上的祖先 */
	}
	low[v0] = min;
}
 
void FindArticul(ALGraph G)
{ /* 连通图G以邻接表作存储结构，查找并输出G上全部关节点。算法7.10 */
  /* 全局量count对访问计数。 */
	int i, v;
	ArcNode *p;
	count = 1;
	low[0] = visited[0] = 1; /* 设定邻接表上0号顶点为生成树的根 */
	for (i = 1; i < G.vexnum; ++i)
		visited[i] = 0; /* 其余顶点尚未访问 */
	p = G.vertices[0].firstarc;
	v = p->adjvex;
	DFSArticul(G, v); /* 从第v顶点出发深度优先查找关节点 */
	if (count < G.vexnum) /* 生成树的根有至少两棵子树 */
	{
		printf("%d %s\n", 0, G.vertices[0].data); /* 根是关节点，输出 */
		while (p->nextarc)
		{
			p = p->nextarc;
			v = p->adjvex;
			if (visited[v] == 0)
				DFSArticul(G, v);
		}
	}
}

int main(){
	int i;
	ALGraph g;
	printf("请选择无向图\n");
	CreateGraph(&g);
	printf("输出关节点：\n");
	FindArticul(g);
	printf(" i G.vertices[i].data visited[i] low[i]\n");
	for (i = 0; i < g.vexnum; ++i)
		printf("%2d %9s %14d %8d\n", i, g.vertices[i].data, visited[i], low[i]);
}

```
## 拓扑排序-代码实现算法7.12
```
#include<bits/stdc++.h>
using namespace std;
typedef int Status; 
typedef int Boolean; 
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2 
#define MAX_NAME 5 
typedef int InfoType;
typedef char VertexType[MAX_NAME]; 
/* ----------------------------------  图的邻接表存储表示    ----------------------------------*/
 
#define MAX_VERTEX_NUM 20
typedef enum { DG, DN, AG, AN }GraphKind; //{有向图,有向网,无向图,无向网} 
typedef struct ArcNode{
	int adjvex; 
	struct ArcNode *nextarc; 
	InfoType *info;
}ArcNode;
typedef struct{
	VertexType data; 
	ArcNode *firstarc; 
}VNode, AdjList[MAX_VERTEX_NUM]; 
typedef struct{
	AdjList vertices;
	int vexnum, arcnum;
    int kind;
}ALGraph; 
/* ---------------------------  需要用的图的邻接表存储的基本操作 --------------------------*/
int LocateVex(ALGraph &G, VertexType u){ 
	int i;
	for (i = 0; i < G.vexnum; ++i)
		if (strcmp(u, G.vertices[i].data) == 0)
			return i;
	return -1;
}
 
Status CreateGraph(ALGraph &G){
	int i, j, k;
	int w; /* 权值 */
	VertexType va, vb;
	ArcNode *p;
	printf("请输入图的类型(有向图:0,有向网:1,无向图:2,无向网:3): ");
	scanf("%d", &G.kind);
	printf("请输入图的顶点数和边数(空格隔开): ");
	scanf("%d%d", &G.vexnum, &G.arcnum);
	printf("请输入%d个顶点的值(<%d个字符):\n", G.vexnum, MAX_NAME);
	for (i = 0; i < G.vexnum; ++i) 
	{
		scanf("%s", G.vertices[i].data);
		G.vertices[i].firstarc = NULL;
	}
	if (G.kind == 1 || G.kind == 3) 
		printf("请顺序输入每条弧(边)的权值、弧尾和弧头(以空格作为间隔):\n");
	else 
		printf("请顺序输入每条弧(边)的弧尾和弧头(以空格作为间隔):\n");
	for (k = 0; k < G.arcnum; ++k) 
	{
		if (G.kind == 1 || G.kind == 3) // 网 
			scanf("%d%s%s", &w, va, vb);
		else // 图
			scanf("%s%s", va, vb);
		i = LocateVex(G, va); // 弧尾 
		j = LocateVex(G, vb); // 弧头 
		p = (ArcNode*)malloc(sizeof(ArcNode));
		p->adjvex = j;
		if (G.kind == 1 || G.kind == 3)	{ // 网 
			p->info = (int *)malloc(sizeof(int));
			*(p->info) = w;
		}
		else
			p->info = NULL; // 图 
		p->nextarc = G.vertices[i].firstarc; // 插在表头 
		G.vertices[i].firstarc = p;
		if (G.kind >= 2){ // 无向图或网,产生第二个表结点
			p = (ArcNode*)malloc(sizeof(ArcNode));
			p->adjvex = i;
			if (G.kind == 3){ // 无向网 
				p->info = (int*)malloc(sizeof(int));
				*(p->info) = w;
			}
			else
				p->info = NULL; // 无向图 
			p->nextarc = G.vertices[j].firstarc; // 插在表头 
			G.vertices[j].firstarc = p;
		}
	}
	return OK;
}
 
 
Boolean visited[MAX_VERTEX_NUM]; 
void(*VisitFunc)(char* v); 
 
 
void Display(ALGraph G){ // 输出图的邻接表G 
	int i;
	ArcNode *p;
	switch (G.kind)
	{
	case DG: printf("有向图\n");
		break;
	case DN: printf("有向网\n");
		break;
	case AG: printf("无向图\n");
		break;
	case AN: printf("无向网\n");
	}
	printf("%d个顶点：\n", G.vexnum);
	for (i = 0; i < G.vexnum; ++i)
		printf("%s ", G.vertices[i].data);
	printf("\n%d条弧(边):\n", G.arcnum);
	for (i = 0; i < G.vexnum; i++){
		p = G.vertices[i].firstarc;
		while (p){
			if (G.kind <= 1) {// 有向 
				printf("%s→%s ", G.vertices[i].data, G.vertices[p->adjvex].data);
				if (G.kind == DN) // 网 
					printf(":%d ", *(p->info));
			}
			else{ // 无向(避免输出两次) 
			
				if (i < p->adjvex)	{
					printf("%s－%s ", G.vertices[i].data, G.vertices[p->adjvex].data);
					if (G.kind == AN) /* 网 */
						printf(":%d ", *(p->info));
				}
			}
			p = p->nextarc;
		}
		printf("\n");
	}
}
 
void FindInDegree(ALGraph G, int indegree[])
{ //求顶点的入度
	int i;
	ArcNode *p;
	for (i = 0; i < G.vexnum; i++)
		indegree[i] = 0; //初始化
	for (i = 0; i < G.vexnum; i++)
	{
		p = G.vertices[i].firstarc;
		while (p)
		{
			indegree[p->adjvex]++;
			p = p->nextarc;
		}
	}
}
 
typedef int SElemType; // 栈类型 
 
 
/* ------------------------------------   栈的顺序存储表示    ----------------------------------*/
 
#define STACK_INIT_SIZE 10 /* 存储空间初始分配量 */
#define STACKINCREMENT 2 /* 存储空间分配增量 */
typedef struct SqStack
{
	SElemType *base; /* 在栈构造之前和销毁之后，base的值为NULL */
	SElemType *top; /* 栈顶指针 */
	int stacksize; /* 当前已分配的存储空间，以元素为单位 */
}SqStack; /* 顺序栈 */
Status InitStack(SqStack *S)
{ /* 构造一个空栈S */
	(*S).base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
	if (!(*S).base)
		exit(OVERFLOW); /* 存储分配失败 */
	(*S).top = (*S).base;
	(*S).stacksize = STACK_INIT_SIZE;
	return OK;
}
 
Status StackEmpty(SqStack S)
{ /* 若栈S为空栈，则返回TRUE，否则返回FALSE */
	if (S.top == S.base)
		return TRUE;
	else
		return FALSE;
}
 
Status Push(SqStack *S, SElemType e)
{ /* 插入元素e为新的栈顶元素 */
	if ((*S).top - (*S).base >= (*S).stacksize) /* 栈满，追加存储空间 */
	{
		(*S).base = (SElemType *)realloc((*S).base, ((*S).stacksize + STACKINCREMENT) * sizeof(SElemType));
		if (!(*S).base)
			exit(OVERFLOW); /* 存储分配失败 */
		(*S).top = (*S).base + (*S).stacksize;
		(*S).stacksize += STACKINCREMENT;
	}
	*((*S).top)++ = e;
	return OK;
}
 
Status Pop(SqStack *S, SElemType *e)
{ /* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
	if ((*S).top == (*S).base)
		return ERROR;
	*e = *--(*S).top;
	return OK;
}
//算法7.12
Status TopologicalSort(ALGraph G){ 
	int i, k, count, indegree[MAX_VERTEX_NUM];
	SqStack S;
	ArcNode *p;
	FindInDegree(G, indegree); // 对各顶点求入度indegree[0..vernum-1] 
	InitStack(&S); // 初始化栈 
	for (i = 0; i < G.vexnum; ++i) // 建零入度顶点栈S 
		if (!indegree[i])
			Push(&S, i); // 入度为0者进栈 
	count = 0; // 对输出顶点计数 
	while (!StackEmpty(S)){ // 栈不空 
		Pop(&S, &i);
		printf("%s ", G.vertices[i].data); // 输出i号顶点并计数 
		++count;
		for (p = G.vertices[i].firstarc; p; p = p->nextarc){ // 对i号顶点的每个邻接点的入度减1 
			k = p->adjvex;
			if (!(--indegree[k])) // 若入度减为0,则入栈 
				Push(&S, k);
		}
	}
	if (count < G.vexnum){
		printf("此有向图有回路\n");
		return ERROR;
	}
	else{
		printf("为一个拓扑序列。\n");
		return OK;
	}
}
 
int main(){
	ALGraph f;
	printf("请选择有向图\n");
	CreateGraph(f);
	Display(f);
	TopologicalSort(f);
}

```
## 关键路径-代码实现算法7.13-7.14
```
#include<bits/stdc++.h>
using namespace std;

typedef int Status;
typedef int Boolean; 
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2 
#define MAX_NAME 5 
typedef int InfoType;
typedef char VertexType[MAX_NAME];
/* ---------------------------------  图的邻接表存储表示    --------------------------------*/
#define MAX_VERTEX_NUM 20
typedef enum { DG, DN, AG, AN }GraphKind; 
typedef struct ArcNode
{
	int adjvex;
	struct ArcNode *nextarc; 
	InfoType *info;
}ArcNode;
typedef struct
{
	VertexType data; 
	ArcNode *firstarc;
}VNode, AdjList[MAX_VERTEX_NUM];
typedef struct
{
	AdjList vertices;
	int vexnum, arcnum;
	int kind; 
}ALGraph;
/* -----------------------------   需要用的图的邻接表存储的基本操作  --------------------------*/ 
int LocateVex(ALGraph G, VertexType u)
{ /* 初始条件: 图G存在,u和G中顶点有相同特征 */
  /* 操作结果: 若G中存在顶点u,则返回该顶点在图中位置;否则返回-1 */
	int i;
	for (i = 0; i < G.vexnum; ++i)
		if (strcmp(u, G.vertices[i].data) == 0)
			return i;
	return -1;
}

Status CreateGraph(ALGraph &G){
	int i, j, k;
	int w; /* 权值 */
	VertexType va, vb;
	ArcNode *p;
	printf("请输入图的类型(有向图:0,有向网:1,无向图:2,无向网:3): ");
	scanf("%d", &G.kind);
	printf("请输入图的顶点数和边数(空格隔开): ");
	scanf("%d%d", &G.vexnum, &G.arcnum);
	printf("请输入%d个顶点的值(<%d个字符):\n", G.vexnum, MAX_NAME);
	for (i = 0; i < G.vexnum; ++i) 
	{
		scanf("%s", G.vertices[i].data);
		G.vertices[i].firstarc = NULL;
	}
	if (G.kind == 1 || G.kind == 3) 
		printf("请顺序输入每条弧(边)的权值、弧尾和弧头(以空格作为间隔):\n");
	else 
		printf("请顺序输入每条弧(边)的弧尾和弧头(以空格作为间隔):\n");
	for (k = 0; k < G.arcnum; ++k) 
	{
		if (G.kind == 1 || G.kind == 3) // 网 
			scanf("%d%s%s", &w, va, vb);
		else // 图
			scanf("%s%s", va, vb);
		i = LocateVex(G, va); // 弧尾 
		j = LocateVex(G, vb); // 弧头 
		p = (ArcNode*)malloc(sizeof(ArcNode));
		p->adjvex = j;
		if (G.kind == 1 || G.kind == 3)	{ // 网 
			p->info = (int *)malloc(sizeof(int));
			*(p->info) = w;
		}
		else
			p->info = NULL; // 图 
		p->nextarc = G.vertices[i].firstarc; // 插在表头 
		G.vertices[i].firstarc = p;
		if (G.kind >= 2){ // 无向图或网,产生第二个表结点
			p = (ArcNode*)malloc(sizeof(ArcNode));
			p->adjvex = i;
			if (G.kind == 3){ // 无向网 
				p->info = (int*)malloc(sizeof(int));
				*(p->info) = w;
			}
			else
				p->info = NULL; // 无向图 
			p->nextarc = G.vertices[j].firstarc; // 插在表头 
			G.vertices[j].firstarc = p;
		}
	}
	return OK;
}

Boolean visited[MAX_VERTEX_NUM]; 
void(*VisitFunc)(char* v); 
 
 
void Display(ALGraph G){ // 输出图的邻接表G 
	int i;
	ArcNode *p;
	switch (G.kind)
	{
	case DG: printf("有向图\n");
		break;
	case DN: printf("有向网\n");
		break;
	case AG: printf("无向图\n");
		break;
	case AN: printf("无向网\n");
	}
	printf("%d个顶点：\n", G.vexnum);
	for (i = 0; i < G.vexnum; ++i)
		printf("%s ", G.vertices[i].data);
	printf("\n%d条弧(边):\n", G.arcnum);
	for (i = 0; i < G.vexnum; i++){
		p = G.vertices[i].firstarc;
		while (p){
			if (G.kind <= 1) {// 有向 
				printf("%s→%s ", G.vertices[i].data, G.vertices[p->adjvex].data);
				if (G.kind == DN) // 网 
					printf(":%d ", *(p->info));
			}
			else{ // 无向(避免输出两次) 
			
				if (i < p->adjvex)	{
					printf("%s－%s ", G.vertices[i].data, G.vertices[p->adjvex].data);
					if (G.kind == AN) /* 网 */
						printf(":%d ", *(p->info));
				}
			}
			p = p->nextarc;
		}
		printf("\n");
	}
}
void FindInDegree(ALGraph G, int indegree[])
{ /* 求顶点的入度，算法7.13调用 */
	int i;
	ArcNode *p;
	for (i = 0; i < G.vexnum; i++)
		indegree[i] = 0; /* 赋初值 */
	for (i = 0; i < G.vexnum; i++)
	{
		p = G.vertices[i].firstarc;
		while (p)
		{
			indegree[p->adjvex]++;
			p = p->nextarc;
		}
	}
}
typedef int SElemType; 
/* -----------------------------------   栈的顺序存储表示   -----------------------------------*/
#define STACK_INIT_SIZE 10
#define STACKINCREMENT 2 
typedef struct SqStack{
	SElemType *base; 
	SElemType *top;
	int stacksize;
}SqStack;
Status InitStack(SqStack &S){ 
	S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
	if (!S.base)
		exit(OVERFLOW);
	S.top = S.base;
	S.stacksize = STACK_INIT_SIZE;
	return OK;
}
 
Status StackEmpty(SqStack S){
	if (S.top == S.base)
		return TRUE;
	else
		return FALSE;
}
 
Status Push(SqStack &S, SElemType e){ 
	if (S.top - S.base >= S.stacksize) {
		S.base = (SElemType *)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType));
		if (!S.base)
			exit(OVERFLOW);
		S.top = S.base + S.stacksize;
		S.stacksize += STACKINCREMENT;
	}
	*(S.top)++ = e;
	return OK;
}
 
Status Pop(SqStack &S, SElemType &e){ /* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */
	if (S.top == S.base)
		return ERROR;
	e = *--S.top;
	return OK;
}

//算法7.13
int ve[MAX_VERTEX_NUM];
Status TopologicalOrder(ALGraph G, SqStack &T){ 
	int j, k, count, indegree[MAX_VERTEX_NUM];
	SqStack S;
	ArcNode *p;
	FindInDegree(G, indegree);
	InitStack(S); 
	for (j = 0; j < G.vexnum; ++j) 
		if (!indegree[j])
			Push(S, j); 
	InitStack(T); 
	count = 0; 
	for (j = 0; j < G.vexnum; ++j) 
		ve[j] = 0;
	while (!StackEmpty(S)){
		Pop(S, j);
		Push(T, j);
		++count;
		for (p = G.vertices[j].firstarc; p; p = p->nextarc){ 
			k = p->adjvex;
			if (--indegree[k] == 0) 
				Push(S, k);
			if (ve[j] + *(p->info) > ve[k])
				ve[k] = ve[j] + *(p->info);
		}
	}
	if (count < G.vexnum)
	{
		printf("此有向网有回路\n");
		return ERROR;
	}
	else
		return OK;
}
//算法7.14
Status CriticalPath(ALGraph G){
	int vl[MAX_VERTEX_NUM];
	SqStack T;
	int i, j, k, ee, el;
	ArcNode *p;
	char dut, tag;
	if (!TopologicalOrder(G, T)) // 产生有向环 
		return ERROR;
	j = ve[0];
	for (i = 1; i < G.vexnum; i++) //j=Max(ve[]) 完成点的值 
		if (ve[i] > j)
			j = ve[i];
	for (i = 0; i < G.vexnum; i++) // 初始化顶点事件的最迟发生时间(最大值) 
		vl[i] = j; // 完成点的最早发生时间 
	while (!StackEmpty(T)) // 按拓扑逆序求各顶点的vl值 
		for (Pop(T, j), p = G.vertices[j].firstarc; p; p = p->nextarc)
		{
			k = p->adjvex;
			dut = *(p->info); // dut<j,k> 
			if (vl[k] - dut < vl[j])
				vl[j] = vl[k] - dut;
		}
	printf(" j  k  dut  ee  el  tag\n");
	for (j = 0; j < G.vexnum; ++j)//求ee,el和关键活动 
		for (p = G.vertices[j].firstarc; p; p = p->nextarc){
			k = p->adjvex;
			dut = *(p->info);
			ee = ve[j];
			el = vl[k] - dut;
			tag = (ee == el) ? '*' : ' ';
			printf("%2d %2d %3d %3d %3d    %c\n", j, k, dut, ee, el, tag); // 输出关键活动 
		}
	printf("关键活动为:\n");
	for (j = 0; j < G.vexnum; ++j) 
		for (p = G.vertices[j].firstarc; p; p = p->nextarc){
			k = p->adjvex;
			dut = *(p->info);
			if (ve[j] == vl[k] - dut)
				printf("%s→%s\n", G.vertices[j].data, G.vertices[k].data); // 输出关键活动 
		}
	return OK;
}
 
int main(){
	ALGraph h;
	printf("请选择有向网\n");
	CreateGraph(h);
	Display(h);
	CriticalPath(h);
}

```
## Dijkstra-代码实现算法7.15
```
#include<bits/stdc++.h>
using namespace std;

/* 函数结果状态代码 */
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2 
typedef int Status; 
typedef int Boolean;  
#define MAX_NAME 5 
#define MAX_INFO 20 
typedef int VRType;
typedef char InfoType;
typedef char VertexType[MAX_NAME];

/* ------------------  图的数组(邻接矩阵)存储表示    ----------------*/ 
#define INFINITY INT_MAX
#define MAX_VERTEX_NUM 20
typedef enum { DG, DN, AG, AN }GraphKind; 
typedef struct{
	VRType adj; 
	InfoType *info; 
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct{
	VertexType vexs[MAX_VERTEX_NUM];
	AdjMatrix arcs; 
	int vexnum, arcnum; 
	GraphKind kind;
}MGraph;

typedef int PathMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef int ShortPathTable[MAX_VERTEX_NUM];

/* -----------  需要用的图的数组(邻接矩阵)存储的基本操作 -----------*/

int LocateVex(MGraph G, VertexType u){ 
/*  初始条件:图G存在,u和G中顶点有相同特征 
    操作结果:若G中存在顶点u,则返回该顶点在图中位置;否则返回-1 */
	int i;
	for (i = 0; i < G.vexnum; ++i)
		if (strcmp(u, G.vexs[i]) == 0)
			return i;
	return -1;
}
 
Status CreateDN(MGraph &G){
	int i, j, k, w, IncInfo;
	char s[MAX_INFO], *info;
	VertexType va, vb;
	printf("请输入有向网G的顶点数,弧数,弧是否含其它信息(是:1,否:0)(以空格作为间隔): ");
	scanf("%d%d%d", &G.vexnum, &G.arcnum, &IncInfo);
	printf("请输入%d个顶点的值(<%d个字符):\n", G.vexnum, MAX_NAME);
	for (i = 0; i < G.vexnum; ++i) 
		scanf("%s", G.vexs[i]);
	for (i = 0; i < G.vexnum; ++i) 
		for (j = 0; j < G.vexnum; ++j){
			G.arcs[i][j].adj = INFINITY; 
			G.arcs[i][j].info = NULL;
		}
	printf("请输入%d条弧的弧尾 弧头 权值(以空格作为间隔): \n", G.arcnum);
	for (k = 0; k < G.arcnum; ++k){
		scanf("%s%s%d%*c", va, vb, &w);  
		i = LocateVex(G, va);
		j = LocateVex(G, vb);
		G.arcs[i][j].adj = w;
		if (IncInfo){
			printf("请输入该弧的相关信息(<%d个字符): ", MAX_INFO);
			gets(s);
			w = strlen(s);
			if (w){
				info = (char*)malloc((w + 1) * sizeof(char));
				strcpy(info, s);
				G.arcs[i][j].info = info; 
			}
		}
	}
	G.kind = DN;
	return OK;
}

//算法7.15
void ShortestPath_DIJ(MGraph G, int v0, PathMatrix &P, ShortPathTable &D){ 
/* 	用Dijkstra算法求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度 
	D[v]。若P[v][w]为TRUE,则w是从v0到v当前求得最短路径上的顶点。 
  	final[v]为TRUE当且仅当v∈S,即已经求得从v0到v的最短路径 算法7.15 */
	int v, w, i, j, min;
	Status final[MAX_VERTEX_NUM];
	for (v = 0; v < G.vexnum; ++v){
		final[v] = FALSE;
		D[v] = G.arcs[v0][v].adj;
		for (w = 0; w < G.vexnum; ++w)
			P[v][w] = FALSE; 
		if (D[v] < INFINITY){
			P[v][v0] = TRUE;
			P[v][v] = TRUE;
		}
	}
	D[v0] = 0;
	final[v0] = TRUE;				// 初始化,v0顶点属于S集 
	for (i = 1; i < G.vexnum; ++i) 	//其余G.vexnum-1个顶点 
	{ 								// 开始主循环,每次求得v0到某个v顶点的最短路径,并加v到S集 
		min = INFINITY; 						// 当前所知离v0顶点的最近距离 
		for (w = 0; w < G.vexnum; ++w)
			if (!final[w]) 						// w顶点在V-S中 
				if (D[w] < min){
					v = w;
					min = D[w];
				} 								//w顶点离v0顶点更近 
		final[v] = TRUE; 						// 离v0顶点最近的v加入S集 
		for (w = 0; w < G.vexnum; ++w) {		// 更新当前最短路径及距离 
			if (!final[w] && min < INFINITY&&G.arcs[v][w].adj < INFINITY && (min + G.arcs[v][w].adj < D[w])){
				D[w] = min + G.arcs[v][w].adj;
				for (j = 0; j < G.vexnum; ++j)
					P[w][j] = P[v][j];
				P[w][w] = TRUE;
			}
		}
	}
}
 
int main(){
	int i, j, v0 = 0; 
	MGraph g;
	PathMatrix p;
	ShortPathTable d;
	CreateDN(g);
	ShortestPath_DIJ(g, v0, p, d);
	printf("最短路径数组 PathMatrix[i][j] 如下:\n");
	for (i = 0; i < g.vexnum; ++i){
		for (j = 0; j < g.vexnum; ++j)
			printf("%2d", p[i][j]);
		printf("\n");
	}
	printf("%s到各顶点的最短路径长度为：\n", g.vexs[0]);
	for (i = 1; i < g.vexnum; ++i)
		printf("%s-%s:%d\n", g.vexs[0], g.vexs[i], d[i]);
	return 0;
}

```
## 弗洛伊德（Floyd）-代码实现算法7.16
```c
#include<bits/stdc++.h>
using namespace std; 
/* 函数结果状态代码 */
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2 
#define MAX_NAME 5 // 顶点字符串的最大长度+1 
#define MAX_INFO 20 // 相关信息字符串的最大长度+1 
typedef int VRType;
typedef char VertexType[MAX_NAME];
typedef char InfoType;
typedef int Status; 
typedef int Boolean;
/* ---------------------------------  图的数组(邻接矩阵)存储表示    --------------------------------*/
 
#define INFINITY INT_MAX // 用整型最大值代替∞ 
#define MAX_VERTEX_NUM 20 // 最大顶点个数 
typedef enum { DG, DN, AG, AN }GraphKind; // {有向图,有向网,无向图,无向网} 
typedef struct{
	VRType adj; 
	InfoType *info; // 该弧相关信息的指针
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct{
	VertexType vexs[MAX_VERTEX_NUM]; // 顶点向量 
	AdjMatrix arcs; 		// 邻接矩阵 
	int vexnum, arcnum; 	// 图的当前顶点数和弧数 
	GraphKind kind; 		// 图的种类标志 
}MGraph;

typedef int PathMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef int ShortPathTable[MAX_VERTEX_NUM];

/* ---------------------------  需要用的图的数组(邻接矩阵)存储的基本操作--------------------------*/
int LocateVex(MGraph G, VertexType u){
	int i;
	for (i = 0; i < G.vexnum; ++i)
		if (strcmp(u, G.vexs[i]) == 0)
			return i;
	return -1;
}
 
Status CreateDN(MGraph *G){ // 采用数组(邻接矩阵)表示法,构造有向网G 
	int i, j, k, w, IncInfo;
	char s[MAX_INFO], *info;
	VertexType va, vb;
	printf("请输入有向网G的顶点数,弧数,弧是否含其它信息(是:1,否:0)(空格隔开): ");
	scanf("%d%d%d", &(*G).vexnum, &(*G).arcnum, &IncInfo);
	printf("请输入%d个顶点的值(<%d个字符):\n", (*G).vexnum, MAX_NAME);
	for (i = 0; i < (*G).vexnum; ++i) // 构造顶点向量 
		scanf("%s", (*G).vexs[i]);
	for (i = 0; i < (*G).vexnum; ++i) // 初始化邻接矩阵 
		for (j = 0; j < (*G).vexnum; ++j){
			(*G).arcs[i][j].adj = INFINITY; // 网 
			(*G).arcs[i][j].info = NULL;
		}
	printf("请输入%d条弧的弧尾 弧头 权值(以空格作为间隔): \n", (*G).arcnum);
	for (k = 0; k < (*G).arcnum; ++k){
		scanf("%s%s%d%*c", va, vb, &w);  // %*c吃掉回车符
		i = LocateVex(*G, va);
		j = LocateVex(*G, vb);
		(*G).arcs[i][j].adj = w; 
		if (IncInfo){
			printf("请输入该弧的相关信息(<%d个字符): ", MAX_INFO);
			gets(s);
			w = strlen(s);
			if (w){
				info = (char*)malloc((w + 1) * sizeof(char));
				strcpy(info, s);
				(*G).arcs[i][j].info = info; 
			}
		}
	}
	(*G).kind = DN;
	return OK;
}
//算法7.16 
typedef int DistancMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
 
void ShortestPath_FLOYD(MGraph G, int (*P)[MAX_VERTEX_NUM][MAX_VERTEX_NUM][MAX_VERTEX_NUM], DistancMatrix *D){ 
	int u, v, w, i;
	for (v = 0; v < G.vexnum; v++) // 各对结点之间初始已知路径及距离 
		for (w = 0; w < G.vexnum; w++){
			(*D)[v][w] = G.arcs[v][w].adj;
			for (u = 0; u < G.vexnum; u++)
				(*P)[v][w][u] = FALSE;
			if ((*D)[v][w] < INFINITY) {
				(*P)[v][w][v] = TRUE;
				(*P)[v][w][w] = TRUE;
			}
		}
	for (u = 0; u < G.vexnum; u++)
		for (v = 0; v < G.vexnum; v++)
			for (w = 0; w < G.vexnum; w++)
				if ((*D)[v][u] + (*D)[u][w] < (*D)[v][w]) {
					(*D)[v][w] = (*D)[v][u] + (*D)[u][w];
					for (i = 0; i < G.vexnum; i++)
						(*P)[v][w][i] = (*P)[v][u][i] || (*P)[u][w][i];
				}
}
 
int  main(){
	MGraph g;
	int i, j, k, l, m, n;
	int p[MAX_VERTEX_NUM][MAX_VERTEX_NUM][MAX_VERTEX_NUM];
	DistancMatrix d;
	CreateDN(&g);
	for (i = 0; i < g.vexnum; i++)
		g.arcs[i][i].adj = 0; // ShortestPath_FLOYD()要求对角元素值为0 
	printf("邻接矩阵:\n");
	for (i = 0; i < g.vexnum; i++){
		for (j = 0; j < g.vexnum; j++)
			printf("%11d", g.arcs[i][j]);
		printf("\n");
	}
	ShortestPath_FLOYD(g, &p, &d);
	printf("d矩阵:\n");
	for (i = 0; i < g.vexnum; i++){
		for (j = 0; j < g.vexnum; j++)
			printf("%6d", d[i][j]);
		printf("\n");
	}
	for (i = 0; i < g.vexnum; i++)
		for (j = 0; j < g.vexnum; j++)
			printf("%s到%s的最短距离为%d\n", g.vexs[i], g.vexs[j], d[i][j]);
	printf("p矩阵:\n");
	l = strlen(g.vexs[0]); // 顶点向量字符串的长度 
	for (i = 0; i < g.vexnum; i++){
		for (j = 0; j < g.vexnum; j++){
			if (i != j){
				m = 0; // 占位空格 
				for (k = 0; k < g.vexnum; k++)
					if (p[i][j][k] == 1)
						printf("%s", g.vexs[k]);
					else
						m++;
				for (n = 0; n < m*l; n++) // 输出占位空格 
					printf(" ");
			}
			else
				for (k = 0; k < g.vexnum*l; k++) // 输出占位空格 
					printf(" ");
			printf("   "); // 输出矩阵元素之间的间距 
		}
		printf("\n");
	}
}
```
