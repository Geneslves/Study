
1.return 退出该语句，return 0正常返回，return 1非正常返回
       strcmp库函数比较字符串是否相等 #include"string.h"
       字符串比较不能直接用 < = > 比较，应该用strcmp
       函数说明在文件开头（所有函数之前），不必在各个函数中声明
       强制类型转换 :(类型名)(表达式)    例            (int)x+y
       结构体   struct 结构体名{成员列表};    . 访问成员变量（结构体名.成员）
  break终止跳出 continue跳出本次循环
        一           控制台输入输出
        (1)字符数据的输入/输出
        字符输出 putchar(int c);
        字符输入 getchar(void);
        (2)格式化输入/输出
        格式输出 printf("格式控制字符串",输出列表);
        格式输入 scanf("格式控制字符串",地址列表);
        (3)字符串的输入/输出
        字符串输出 puts(const char *str);
        字符串输入 gets(char *str);
        scanf不能接受空格、制表符Tab、回车等；对末尾回车符的处理           把回车符保留在缓存中。
        gets能够接受空格、制表符Tab和回车等；对末尾回车符的处理           接收回车，但把回车替换为\0。
        二           文件的读写
        (1)读写一个字符
        字符写函数 fputc(c,fp);
        字符读函数 fgetc(fp);
        (2)块读写
        二进制写函数 fwrite(buffer,size,count,fp);
        二进制读函数 fread(buffer,size,count,fp);
        格式化写函数 fprintf(文件指针,格式字符串,输出项表列);
        格式化读函数 fscanf(文件指针,格式字符串,地址参数列表);
        (3)其他读写函数
        磁盘文件写函数 putw(10,fp);
        磁盘文件读函数 getw(fp);
        文件字符串写函数 fputs(字符串,文件指针);
        文件字符串读函数 fgets(字符串数组名,n,文件指针);
  输入存在输入缓存区
########分支语句（if/switch）
2.if(){}  
    else if()
        {} 
        else
3.switch(){
    case:
    case: 
        break
    case；
        break
    default:        -----默认
    }
########循环语句
4.while (条件){
    循环语句           
    break;
    continue;
    }
5.for (表达式1;表达式2;表达式3){
      初始化  判断    调整
    循环语句
    }
            流程           表达式1->表达式2->循环体->   表达式3->   表达式2
            表达式都可以省略   判断省略恒为真
6.do{
    循环体
    }
 while (表达式)
7.递归运算速度慢，栈溢出
8.操作符
 .   访问成员变量（结构体名.成员）
 ->  结构体指针 -> 成员名  
exp1 , exp2 , .... , e++-xpN         逗号表达式            从左向右依次计算，最后结果为最后表达式结果
表达式1 ? 表达式2 : 表达式3        表达式1为真，取表达式2，否则取表达式3    唯一的三目运算符
================================================================================================================================
1.断言：
 assert 宏的原型定义在 assert.h 中，其作用是如果它的条件返回错误，则终止程序执行。
    #include "assert.h" 
    void assert( int expression );
 assert 的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。
 使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。
 在调试结束后，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用，示例代码如下：
    #include 
    #define NDEBUG 
    #include
 以下是使用断言的几个原则：
 （1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。
 （2）使用断言对函数的参数进行确认。
 （3）在编写函数时，要进行反复的考查，并且自问："我打算做哪些假定？"一旦确定了的假定，就要使用断言对假定进行检查。
 （4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果"不可能发生"的事情的确发生了，
      则要使用断言进行报警。
--------------------------------------------------------------------------------------------------------------------------------
2.const修饰指针变量的时候：
 1. const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变。
 2. const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变。
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
================================================================================================================================
================================================================================================================================

                                                数组

--------------------------------------------------------------------------------------------------------------------------------
数组名是首元素地址
sizeof(数组名)，计算整个数组的大小，单位是字节，sizeof内部单独放一个数组名，数组名表示整个数组
&数组名，取出的是数组的地址。&数组名，数组名表示整个数组
一维数组创建，[]中要给一个   常量  ，不能使用变量
    sizeof 计算所占空间的大小   计算变量、数组、类型的大小---单位是字节  --操作符
    strlen 求字符串的长度---'\0'之前的字符个数，只能求字符串长度----库函数--使用得引用头文件
    sizeof 和 strlen 没有关系
二维数组创建不能省略列标  [][]行列
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
================================================================================================================================


================================================================================================================================
================================================================================================================================

                                                 指针

--------------------------------------------------------------------------------------------------------------------------------
指针           * （解引用操作符（通过地址取其值））取值，& 取地址
--------------------------------------------------------------------------------------------------------------------------------
                                        arr[i] == *(arr+i) == *(p+i) == p[i]                     //test_2210_30
                                        int 为原数组或函数类型
int arr[5];               arr是一个5元素的整型数组    
int *parr1[10];           parr1是一个数组，数组有10个元素，每个元素的类型是 int*，parr1是指针数组
int (*parr2)[10];         parr2是一个指针，该指针指向了一个数组，数组有10个元素，每个元素类型是int，parr2是数组指针
int (*parr3[10])[5];      parr3是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int
int (*p)(int ,int)        函数指针                  int (*)()---类型    p-----函数名
int (*p[])(int ,int )     函数指针数组          --用途：转移表
--------------------------------------------------------------------------------------------------------------------------------
&函数名 和 函数名 都是函数的地址

int*   类型指针，接收int类型的地址
char*  类型指针，可以接收char类型的地址  
void*  类型指针，可以接收任意类型地址，不能进行解引用（*）操作，不能进行+ -整数的操作

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就
说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
================================================================================================================================


================================================================================================================================
================================================================================================================================

                                                  字符串
--------------------------------------------------------------------------------------------------------------------------------
C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在 常量字符串 中或者 字符数组 中。
字符串常量 适用于那些对它不做修改的字符串函数.
头文件        #include "string.h"
--------------------------------------------------------------------------------------------------------------------------------
求字符串长度
        strlen
长度不受限制的字符串函数       遇到字符串的'\0'才停止
        strcpy        复制
        strcat        追加
        strcmp        比较对应字符
长度受限制的字符串函数介绍
        strncpy
        strncat
        strncmp
字符串查找
        strstr     寻找字符串中的子串
        strtok     按字符分隔字符串
错误信息报告
        strerror   错误码分析
字符操作
                                                    ******************************字符串函数以'\0'结尾
内存操作函数
        memcpy
        memmove
        memset
        memcmp
--------------------------------------------------------------------------------------------------------------------------------
1.strlen          size_t strlen ( const char * str );
    字符串以 '\0' 作为结束标志，strlen函数返回的是在字符串中 '\0' 前面出现的字符个数（不包含 '\0' )。
    参数指向的字符串必须要以 '\0' 结束。
    注意函数的返回值为size_t，是无符号的（ 易错 ）
    学会strlen函数的模拟实现                           test_22\2211\test_2211_6\1_test.c
--------------------------------------------------------------------------------------------------------------------------------
2. strcpy       char* strcpy(char * destination, const char * source );
    Copies the C string pointed by source into the array pointed by destination, including theterminating null character (and 
            stopping at that point).
    源字符串必须以 '\0' 结束。
    会将源字符串中的 '\0' 拷贝到目标空间。
    目标空间必须足够大，以确保能存放源字符串。
    目标空间必须可变。
    学会模拟实现。                                    test_22\2211\test_2211_6\2_test.c
    strcopy(arr1,arr2);   把arr2拷贝到arr1; 替换arr1中的对应字符
--------------------------------------------------------------------------------------------------------------------------------
3. strcat       char * strcat ( char * destination, const char * source );
    Appends a copy of the source string to the destination string. The terminating null characterin destination is overwritten by
     the first character of source, and a null-character is includedat the end of the new string formed by the concatenation of
     both in destination.
    源字符串必须以 '\0' 结束。以目标字符串的'\0'开始追加。
    目标空间必须有足够的大，能容纳下源字符串的内容。
    目标空间必须可修改。
    字符串自己给自己追加，如何？              找不到'\0'进入死循环
                                                    test_22\2211\test_2211_6\3_test.c
--------------------------------------------------------------------------------------------------------------------------------
4 strcmp         int strcmp ( const char * str1, const char * str2 );
    This function starts comparing the first character of each string. If they are equal to eachother, it continues with the 
    following pairs until the characters differ or until a terminating null-character is reached.
    标准规定：
        第一个字符串大于第二个字符串，则返回大于0的数字
        第一个字符串等于第二个字符串，则返回0
        第一个字符串小于第二个字符串，则返回小于0的数字
                                                    test_22\2211\test_2211_7\1_test.c
--------------------------------------------------------------------------------------------------------------------------------
5.strncpy        char * strncpy ( char * destination, const char * source, size_t num );
    Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a 
    null-character) is found before num characters have been copied,destination is padded with zeros until a total of num 
    characters have been written to it.
    拷贝num个字符从源字符串到目标空间。不自动追加'\0'
    如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0（\0），直到num个。
    
--------------------------------------------------------------------------------------------------------------------------------
6.strncat       char * strncat ( char * destination, const char * source, size_t num );
    Appends the first num characters of source to destination, plus a terminating null-character.
    If the length of the C string in source is less than num, only the content up to the terminatingnull-character is copied.
    在追加字符串最后自动追加'\0'
--------------------------------------------------------------------------------------------------------------------------------
7.strncmp        int strncmp ( const char * str1, const char * str2, size_t num );
    比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完。
--------------------------------------------------------------------------------------------------------------------------------
8.strstr         char * strstr ( const char *str1, const char * str2);
    Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part ofstr1.
                                                                test_22\2211\test_2211_8\1_test.c
--------------------------------------------------------------------------------------------------------------------------------
9.strtok            char * strtok ( char * str, const char * sep );
    sep参数是个字符串，定义了用作分隔符的字符集合
    第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记
    strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用
                                                                        strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）
    strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。
    strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。
    如果字符串中不存在更多的标记，则返回 NULL 指针。
                                                                test_22\2211\test_2211_9\1_test.c
--------------------------------------------------------------------------------------------------------------------------------
10.strerror       char * strerror ( int errnum );
    返回错误码，所对应的错误信息。
    使用方式 strerror(errno)    errno--#include "errno.h"       test_22\2211\test_2211_9\2_test.c   
--------------------------------------------------------------------------------------------------------------------------------
11.字符分类函数   #include "ctypez.h"
    函数         如果他的参数符合下列条件就返回真
    iscntrl      任何控制字符
    isspace      空白字符：空格‘ ’，换页‘\f’，换行'\n'，回车‘\r’，制表符'\t'或者垂直制表符'\v'
    isdigit      十进制数字 0~9
    isxdigit     十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F
    islower      小写字母a~z
    isupper      大写字母A~Z
    isalpha      字母a~z或A~Z
    isalnum      字母或者数字，a~z,A~Z,0~9
    ispunct      标点符号，任何不属于数字或者字母的图形字符（可打印）
    isgraph      任何图形字符
    isprint      任何可打印字符，包括图形字符和空白字符
--------------------------------------------------------------------------------------------------------------------------------
12.字符转换函数      #include "ctype.h"
    int tolower ( int c )     tolower()---转小写（单个字符）
    int toupper ( int c )     toupper()---转大写（单个字符）
--------------------------------------------------------------------------------------------------------------------------------
13.memcpy    void * memcpy ( void * destination, const void * source, size_t num )
    函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。
    这个函数在遇到 '\0' 的时候并不会停下来。
    如果source和destination有任何的重叠，复制的结果都是未定义的。
                                                                test_22\2211\test_2211_9\3_test.c
--------------------------------------------------------------------------------------------------------------------------------
12 memmove  void * memmove ( void * destination, const void * source, size_t num );
    和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。
    如果源空间和目标空间出现重叠，就得使用memmove函数处理。
                                                                test_22\2211\test_2211_9\4_test.c
--------------------------------------------------------------------------------------------------------------------------------
13.memcmp  int memcmp ( const void * ptr1, const void * ptr2, size_t num );
    比较从ptr1和ptr2指针开始的num个字节
                                                                test_22\2211\test_2211_9\5_test.c
--------------------------------------------------------------------------------------------------------------------------------
14.memset  void *memset( void * dest, int c, size_t count);
    内存设置            位置          填充符号       填充字节大小
                                                                test_22\2211\test_2211_9\5_test.c
--------------------------------------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
================================================================================================================================


================================================================================================================================
================================================================================================================================

                                                   结构体

--------------------------------------------------------------------------------------------------------------------------------
C语言允许用户使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构
型名称、共用型名称、枚举型名称等。一旦用户在程序中定义了自己的数据类型名称，就可以在该程序中用自己的数据类型名称来定义变量的类型、数组的
类型、指针变量的类型与函数的类型等。
--------------------------------------------------------------------------------------------------------------------------------
->是一个整体，它是用于指向结构体、C++中的class等含有子数据的指针用来取子数据。换种说法，如果我们在C语言中定义了一个结构体，然后申明一个
指针指向这个结构体，那么我们要用指针取出结构体中的数据，就要用到“->”.
结构体传参的时候，要传结构体的地址。
--------------------------------------------------------------------------------------------------------------------------------
struct tag                        结构体关键字  结构体标签    struct tag 结构体类型
{
    member-list;                  成员变量
}varuable-list;                   全局变量
--------------------------------------------------------------------------------------------------------------------------------
typedef struct Stu               重新定义类型名
{

}stu;                            定义：（1）struct Stu s1       /       （2）stu s2 
--------------------------------------------------------------------------------------------------------------------------------
结构体自引用
    typedef struct Node
    {
        int data;
        struct Node* next;
    }Node;
--------------------------------------------------------------------------------------------------------------------------------
结构体内存对齐
    1. 第一个成员在与结构体变量偏移量为0的地址处。
    2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
                对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。            VS中默认的值为8     gcc没有默认值（4）
    3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
    4. 如果嵌套了结构体的情况，嵌套结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。
    为什么存在内存对齐?
        大部分的参考资料都是如是说的：
        1. 平台原因(移植原因)：
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
        2. 性能原因：
        数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
        原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
    总体来说：
        结构体的内存对齐是拿空间来换取时间的做法。
        那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：让占用空间小的成员尽量集中在一起。
--------------------------------------------------------------------------------------------------------------------------------
修改默认对齐数
    #pragma 这个预处理指令，可以改变我们的默认对齐数。
    #pragma pack(8)//设置默认对齐数为8
    #pragma pack()//取消设置的默认对齐数，还原为默认
    size_t offsetof(structName,memberName)        offsetof(,)
--------------------------------------------------------------------------------------------------------------------------------
位段
    位段的声明和结构是类似的，有两个不同：
    1.位段的成员必须是 int、unsigned int 或signed int 。
    2.位段的成员名后边有一个冒号和一个数字。
  位段的内存分配
    1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
    2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
    3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
  位段的跨平台问题
    1. int 位段被当成有符号数还是无符号数是不确定的。
    2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
    3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
    4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的
 总结：
    跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在    
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
函数传参压栈操作
内存分区     栈区      局部变量、函数的形式参数、函数调用时开辟的空间
            堆区      动态内存分配、molloc/free、realloc、calloc
            静态区    全局变量、静态变量
--------------------------------------------------------------------------------------------------------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
================================================================================================================================


================================================================================================================================
================================================================================================================================

                                                   运算符

--------------------------------------------------------------------------------------------------------------------------------

1   后缀运算符           []    ()    ·    ->    ++    --(类型名称){列表}	            从左到右
2	一元运算符           ++    --    !    ~     +     -    *    &    sizeof_Alignof	   从右到左
3	类型转换运算符       (类型名称)	                                                    从右到左
4	乘除法运算符         *     /    %	                                               从左到右
5	加减法运算符         +     -	                                                   从左到右
6	移位运算符           <<    >>	                                                   从左到右
7	关系运算符           <<=   >>=	                                                   从左到右
8	相等运算符           ==    !=	                                                   从左到右
9	位运算符 AND         &	                                                           从左到右
10	位运算符 XOR         ^	                                                           从左到右
11	位运算符 OR          |	                                                           从左到右
12	逻辑运算符 AND       &&	                                                           从左到右
13	逻辑运算符 OR        ||	                                                           从左到右
14	条件运算符           ?:	                                                           从右到左
15	赋值运算符           =     +=    -=   *=   /=     %=   &=    ^=   |=   <<=  >>=	   从右到左
16	逗号运算符           ，	                                                           从左到右
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
================================================================================================================================


================================================================================================================================
================================================================================================================================


--------------------------------------------------------------------------------------------------------------------------------
================================================================================================================================
================================================================================================================================
Bin	       Dec	Hex	缩写/字符	                      解释
00000000	0	00	NUL(null)	                    空字符
00000001	1	01	SOH(start of headling)	        标题开始
00000010	2	02	STX (start of text)	            正文开始
00000011	3	03	ETX (end of text)	            正文结束
00000100	4	04	EOT (end of transmission)	    传输结束
00000101	5	05	ENQ (enquiry)	                请求
00000110	6	06	ACK (acknowledge)	            收到通知
00000111	7	07	BEL (bell)	                    响铃
00001000	8	08	BS (backspace)	                退格
00001001	9	09	HT (horizontal tab)	            水平制表符
00001010	10	0A	LF (NL line feed, new line)	    换行键
00001011	11	0B	VT (vertical tab)	            垂直制表符
00001100	12	0C	FF (NP form feed, new page)	    换页键
00001101	13	0D	CR (carriage return)	        回车键
00001110	14	0E	SO (shift out)	                不用切换
00001111	15	0F	SI (shift in)	                启用切换
00010000	16	10	DLE (data link escape)	        数据链路转义
00010001	17	11	DC1 (device control 1)	        设备控制1
00010010	18	12	DC2 (device control 2)	        设备控制2
00010011	19	13	DC3 (device control 3)	        设备控制3
00010100	20	14	DC4 (device control 4)	        设备控制4
00010101	21	15	NAK (negative acknowledge)	    拒绝接收
00010110	22	16	SYN (synchronous idle)	        同步空闲
00010111	23	17	ETB (end of trans. block)	    传输块结束
00011000	24	18	CAN (cancel)	                取消
00011001	25	19	EM (end of medium)	            介质中断
00011010	26	1A	SUB (substitute)	            替补
00011011	27	1B	ESC (escape)	                溢出
00011100	28	1C	FS (file separator)	            文件分割符
00011101	29	1D	GS (group separator)	        分组符
00011110	30	1E	RS (record separator)	        记录分离符
00011111	31	1F	US (unit separator)	            单元分隔符
00100000	32	20	(space)	                        空格
00100001	33	21	!	
00100010	34	22	"	
00100011	35	23	#	
00100100	36	24	$	
00100101	37	25	%	
00100110	38	26	&	
00100111	39	27	'	
00101000	40	28	(	
00101001	41	29	)	
00101010	42	2A	*	
00101011	43	2B	+	
00101100	44	2C	,	
00101101	45	2D	-	
00101110	46	2E	.	
00101111	47	2F	/	
00110000	48	30	0	
00110001	49	31	1	
00110010	50	32	2	
00110011	51	33	3	
00110100	52	34	4	
00110101	53	35	5	
00110110	54	36	6	
00110111	55	37	7	
00111000	56	38	8	
00111001	57	39	9	
00111010	58	3A	:	
00111011	59	3B	;	
00111100	60	3C	<	
00111101	61	3D	=	
00111110	62	3E	>	
00111111	63	3F	?	
01000000	64	40	@	
01000001	65	41	A	
01000010	66	42	B	
01000011	67	43	C	
01000100	68	44	D	
01000101	69	45	E	
01000110	70	46	F	
01000111	71	47	G	
01001000	72	48	H	
01001001	73	49	I	
01001010	74	4A	J	
01001011	75	4B	K	
01001100	76	4C	L	
01001101	77	4D	M	
01001110	78	4E	N	
01001111	79	4F	O	
01010000	80	50	P	
01010001	81	51	Q	
01010010	82	52	R	
01010011	83	53	S	
01010100	84	54	T	
01010101	85	55	U	
01010110	86	56	V	
01010111	87	57	W	
01011000	88	58	X	
01011001	89	59	Y	
01011010	90	5A	Z	
01011011	91	5B	[	
01011100	92	5C	\	
01011101	93	5D	]	
01011110	94	5E	^	
01011111	95	5F	_	
01100000	96	60	`	
01100001	97	61	a	
01100010	98	62	b	
01100011	99	63	c	
01100100	100	64	d	
01100101	101	65	e	
01100110	102	66	f	
01100111	103	67	g	
01101000	104	68	h	
01101001	105	69	i	
01101010	106	6A	j	
01101011	107	6B	k	
01101100	108	6C	l	
01101101	109	6D	m	
01101110	110	6E	n	
01101111	111	6F	o	
01110000	112	70	p	
01110001	113	71	q	
01110010	114	72	r	
01110011	115	73	s	
01110100	116	74	t	
01110101	117	75	u	
01110110	118	76	v	
01110111	119	77	w	
01111000	120	78	x	
01111001	121	79	y	
01111010	122	7A	z	
01111011	123	7B	{	
01111100	124	7C	|	
01111101	125	7D	}	
01111110	126	7E	~	
01111111	127	7F	DEL (delete)	                删除
================================================================================================================================